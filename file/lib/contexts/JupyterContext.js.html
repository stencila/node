<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">lib/contexts/JupyterContext.js | stencila-node</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Stencila for Node.js"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="stencila-node"><meta property="twitter:description" content="Stencila for Node.js"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/stencila/node"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#contexts">contexts</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/contexts/Context.js~Context.html">Context</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/contexts/JavascriptContext.js~JavascriptContext.html">JavascriptContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/contexts/JupyterContext.js~JupyterContext.html">JupyterContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/contexts/NodeContext.js~NodeContext.html">NodeContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/contexts/SqliteContext.js~SqliteContext.html">SqliteContext</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#host">host</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/host/Host.js~Host.html">Host</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/host/HostHttpServer.js~HostHttpServer.html">HostHttpServer</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/contexts/JupyterContext.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const fs = require(&apos;fs&apos;)
const jmp = require(&apos;jmp&apos;)
const kernelspecs = require(&apos;kernelspecs&apos;)
const spawnteract = require(&apos;spawnteract&apos;)
const uuid = require(&apos;uuid&apos;)

const Context = require(&apos;./Context&apos;)

/**
 * An execution context using Jupyter kernels
 *
 * This class of execution context acts as a bridge between Stencila and
 * Jupyter kernels. It exposes methods of the Stencila `Context` API e.g. `executeEval`
 * which delegate execution to a Jupyter kernel. This is done via the
 * [Jupyter Messageing Protocol (JMP)](http://jupyter-client.readthedocs.io/en/stable/messaging.html)
 * over [ZeroMQ](http://zeromq.org/) sockets.
 *
 * The `discover` static method should be called initially to find all Jupyter kernels
 * currently installed on the machine and update `JupyterContext.spec.kernels`:
 *
 *     JupyterContext.discover()
 *
 * New Jupyter execution contexts can be constructed using the `language` option which will
 * search for a kernel with a matching lowercased `language` property:
 *
 *     new JupyterContext({language:&apos;r&apos;})
 *
 * Alternively, you can specify a kernel directly:
 *
 *     new JupyterContext({kernel:&apos;ir&apos;})
 *
 * See https://github.com/jupyter/jupyter/wiki/Jupyter-kernels for a list of available
 * Jupyter kernels.
 *
 * Many thanks to the nteract community for [`kernelspecs`](https://github.com/nteract/kernelspecs) and
 * [`spawnteract`](https://github.com/nteract/spawnteract), and to Nicolas Riesco for (`jmp`)[https://github.com/n-riesco/jmp],
 * all of which made this implementation far easier!
 */
class JupyterContext extends Context {
  /**
   * Discover Jupyter kernels on the current machine
   *
   * Looks for Jupyter kernels that have been installed on the system
   * and puts that list in `JupyterContext.spec.kernels` so that
   * peers know the capabilities of this &quot;meta-context&quot;.
   *
   * @return {Promise} A promise
   */
  static discover () {
    // Create a list of kernel names and aliases
    return kernelspecs.findAll().then(kernelspecs =&gt; {
      JupyterContext.spec.kernels = kernelspecs
    })
  }

  /**
   * Construct a Jupyter execution context
   *
   * @param  {Object} options Options for specifying which kernel to use
   */
  constructor (host, name, options = {}) {
    super(host, name)

    let kernel = options.kernel
    let kernelName = options.name
    const kernels = JupyterContext.spec.kernels
    const kernelNames = Object.keys(kernels)

    if (!kernelNames.length) {
      throw new Error(&apos;No Jupyter kernels available on this machine&apos;)
    }
    if (kernel &amp;&amp; !kernels[kernel]) {
      throw new Error(`Jupyter kernel &quot;${kernel}&quot; not available on this machine`)
    }
    if (kernelName) {
      for (let spec of kernels) {
        if (spec.name.toLowerCase() === kernelName) {
          kernel = spec.name
          break
        }
      }
      if (!kernel) {
        throw new Error(`No Jupyter kernel on this machine with name &quot;${kernelName}&quot;`)
      }
    }
    if (!kernel) {
      if (kernelNames.indexOf(&apos;python3&apos;) &gt;= 0) kernel = &apos;python3&apos;
      else kernel = kernelNames[0]
    }
    this.kernel = kernel

    this.debug = options.debug || false
    this.timeout = options.timeout || -1
  }

  /**
   * Initialize the context
   *
   * @return {Promise} A promise
   */
  initialize () {
    if (this._process) return Promise.resolve()
    else {
      // Options to [child_process.spawn]{@link https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options}
      let options = {}
      // Pass `kernels` to `launch()` as an optimization to prevent another kernelspecs search of filesystem
      return spawnteract.launch(this.kernel, options, JupyterContext.spec.kernels).then(kernel =&gt; {
        this._process = kernel.spawn // The running process, from child_process.spawn(...)
        this._connectionFile = kernel.connectionFile // Connection file path
        this._config = kernel.config // Connection information from the file
        this._spec = kernel.kernelSpec

        // Unique session id for requests
        this._sessionId = uuid()

        // Map of requests for handling response messages
        this._requests = {}

        const origin = this._config.transport + &apos;://&apos; + this._config.ip

        // Shell socket for execute, and other, request
        this._shellSocket = new jmp.Socket(&apos;dealer&apos;, &apos;sha256&apos;, this._config.key)
        this._shellSocket.connect(origin + &apos;:&apos; + this._config.shell_port)
        this._shellSocket.on(&apos;message&apos;, this._response.bind(this))

        // IOPub socket for receiving updates
        this._ioSocket = new jmp.Socket(&apos;sub&apos;, &apos;sha256&apos;, this._config.key)
        this._ioSocket.connect(origin + &apos;:&apos; + this._config.iopub_port)
        this._ioSocket.on(&apos;message&apos;, this._response.bind(this))
        this._ioSocket.subscribe(&apos;&apos;) // Subscribe to all topics

        // Get kernel info mainly to confirm communication with kernel is
        // working
        return this._request(&apos;kernel_info_request&apos;, {}, [&apos;kernel_info_reply&apos;]).then(({request, response}) =&gt; {
          this._kernelInfo = response.content
          // This wait seems to be necessary in order for messages to be received on
          // `this._ioSocket`.
          return new Promise((resolve, reject) =&gt; {
            setTimeout(resolve, 1000)
          })
        })
      })
    }
  }

  /**
   * Finalize the context
   *
   * @return {Promise} A resolved promise
   */
  finalize () {
    if (this._shellSocket) {
      this._shellSocket.removeAllListeners(&apos;message&apos;)
      this._shellSocket.close()
      this._shellSocket = null
    }
    if (this._ioSocket) {
      this._ioSocket.removeAllListeners(&apos;message&apos;)
      this._ioSocket.close()
      this._ioSocket = null
    }
    if (this._process) {
      this._process.kill()
      this._process = null
    }
    if (this._connectionFile) {
      fs.unlinkSync(this._connectionFile)
      this._connectionFile = null
    }
    this._config = null
    this._spec = null
    return Promise.resolve()
  }

  /**
   * Execute a cell
   *
   * For cells with `expr: true` utilises `user_expressions` property of an `execute_request` to
   * evaluate expression side-effect free.
   *
   * @override
   */
  async execute (cell) {
    // Compile the cell so it has correct structure
    cell = await this.compile(cell)

    // For expression cells, use `user_expressions`, not `code`
    // to ensure there are no side effects (?)
    let code
    let expressions
    if (cell.expr) {
      code = &apos;&apos;
      expressions = {
        &apos;value&apos;: cell.source.data
      }
    } else {
      code = cell.source.data
      expressions = {}
    }

    let content = {
      // Source code to be executed by the kernel, one or more lines.
      &apos;code&apos;: code,

      // A boolean flag which, if True, signals the kernel to execute
      // this code as quietly as possible.
      // silent=True forces store_history to be False,
      // and will *not*:
      //   - broadcast output on the IOPUB channel
      //   - have an execute_result
      // The default is False.
      &apos;silent&apos;: false,

      // A boolean flag which, if True, signals the kernel to populate history
      // The default is True if silent is False.  If silent is True, store_history
      // is forced to be False.
      &apos;store_history&apos;: true,

      // A dict mapping names to expressions to be evaluated in the
      // user&apos;s dict. The rich display-data representation of each will be evaluated after execution.
      // See the display_data content for the structure of the representation data.
      &apos;user_expressions&apos;: expressions,

      // Some frontends do not support stdin requests.
      // If this is true, code running in the kernel can prompt the user for input
      // with an input_request message (see below). If it is false, the kernel
      // should not send these messages.
      &apos;allow_stdin&apos;: false,

      // A boolean flag, which, if True, does not abort the execution queue, if an exception is encountered.
      // This allows the queued execution of multiple execute_requests, even if they generate exceptions.
      &apos;stop_on_error&apos;: false
    }
    return this._request(&apos;execute_request&apos;, content).then(({request, response}) =&gt; {
      const msgType = response.header.msg_type
      switch (msgType) {
        case &apos;execute_result&apos;:
        case &apos;display_data&apos;:
          // Success! Unbundle the execution result, insert it into cell
          // outputs and then return the cell
          return this._unbundle(response.content.data).then(value =&gt; {
            cell.outputs.push({value})
            return cell
          })
        case &apos;execute_reply&apos;:
          // We get  `execute_reply` messages when there is no
          // execution result (e.g. an assignment), or when evaluating
          // a user expression
          const result = response.content.user_expressions.value
          if (result) {
            if (result.status === &apos;ok&apos;) {
              return this._unbundle(result.data).then(value =&gt; {
                cell.outputs.push({value})
                return cell
              })
            } else if (result &amp;&amp; result.status === &apos;error&apos;) {
              cell.messages.push({
                type: &apos;error&apos;,
                message: result.ename + &apos;: &apos; + result.evalue
              })
              return cell
            }
          } else {
            return cell
          }
          break
        case &apos;error&apos;:
          // Errrror :( Add an error message to the cell
          const error = response.content
          cell.messages.push({
            type: &apos;error&apos;,
            message: error.ename + &apos;: &apos; + error.evalue
          })
          return cell
        default:
          if (this.debug) console.log(`Unhandled message type: ${msgType}`)
      }
    }).catch(error =&gt; {
      // Some other error happened...
      cell.messages.push({
        type: &apos;error&apos;,
        message: error.message
      })
      return cell
    })
  }

  /**
   * Send a request message to the kernal
   *
   * @private
   * @param  {String} requestType  Type of request e.g. &apos;execute&apos;
   * @param  {Object} content      Content of message
   * @param  {String} responseTypes Types of response message to resolve
   * @returns {Promise} Promise resolving to the {request, response} messages
   */
  _request (requestType, content, responseTypes = [&apos;execute_result&apos;, &apos;display_data&apos;, &apos;execute_reply&apos;, &apos;error&apos;]) {
    return new Promise((resolve, reject) =&gt; {
      var request = new jmp.Message()
      request.idents = []
      request.header = {
        &apos;msg_id&apos;: uuid(),
        &apos;username&apos;: &apos;user&apos;,
        &apos;session&apos;: this._sessionId,
        &apos;msg_type&apos;: requestType,
        &apos;version&apos;: &apos;5.2&apos;
      }
      request.parent_header = {}
      request.metadata = {}
      request.content = content

      this._requests[request.header.msg_id] = {
        request,
        responseTypes,
        handler: (response) =&gt; resolve({request, response})
      }
      this._shellSocket.send(request)

      // If this request has not been handled before `timeout`
      // throw an error
      if (this.timeout &gt;= 0) {
        setTimeout(() =&gt; {
          if (this._requests[request.header.msg_id]) {
            reject(new Error(&apos;Request timed out&apos;))
          }
        }, this.timeout * 1000)
      }
    })
  }

  /**
   * Receive a response message from the kernel
   *
   * @private
   * @param  {Message} response Response message
   */
  _response (response) {
    const requestId = response.parent_header.msg_id
    const responseType = response.header.msg_type
    const request = this._requests[requestId]
    if (this.debug) {
      console.log(&apos;Response: &apos;, requestId, responseType, response.content)
    }
    // First response matching the request, including response type
    // calls handler
    if (request &amp;&amp; request.responseTypes.indexOf(responseType) &gt; -1) {
      request.handler(response)
      delete this._requests[requestId]
    }
  }

  /**
   * Convert a &quot;MIME bundle&quot; within a JMP message (e.g. a `execute_result` or
   * `display data` message) into a data node
   * e.g. `{&apos;text/plain&apos;: &apos;Hello&apos;}` to `{type: &apos;string&apos;, data: &apos;Hello&apos;}`
   *
   * @private
   * @param  {Object} bundle A JMP MIME bundle
   * @return {Promise}       Promise resolving to a data node
   */
  _unbundle (bundle) {
    return Promise.resolve().then(() =&gt; {
      const image = bundle[&apos;image/png&apos;]
      if (image) {
        return {
          type: &apos;image&apos;,
          src: &apos;data:image/png;base64,&apos; + image
        }
      }

      const text = bundle[&apos;text/plain&apos;]
      if (text) {
        // Attempt to parse to JSON
        try {
          return JSON.parse(text)
        } catch (error) {
          return text
        }
      }
    }).then(value =&gt; {
      return this.pack(value)
    })
  }
}

JupyterContext.spec = {
  name: &apos;JupyterContext&apos;,
  client: &apos;ContextHttpClient&apos;,
  kernels: {} // Populated by JupyterContext.setup
}

module.exports = JupyterContext
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
