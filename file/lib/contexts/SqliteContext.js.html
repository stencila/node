<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">lib/contexts/SqliteContext.js | stencila-node</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Stencila for Node.js"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="stencila-node"><meta property="twitter:description" content="Stencila for Node.js"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/stencila/node"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#contexts">contexts</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/contexts/Context.js~Context.html">Context</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/contexts/JavascriptContext.js~JavascriptContext.html">JavascriptContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/contexts/JupyterContext.js~JupyterContext.html">JupyterContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/contexts/NodeContext.js~NodeContext.html">NodeContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/contexts/SqliteContext.js~SqliteContext.html">SqliteContext</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#host">host</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/host/Host.js~Host.html">Host</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/host/HostHttpServer.js~HostHttpServer.html">HostHttpServer</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/contexts/SqliteContext.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const assert = require(&apos;assert&apos;)
const crypto = require(&apos;crypto&apos;)
const Database = require(&apos;better-sqlite3&apos;)
const sqliteParser = require(&apos;sqlite-parser&apos;)
const uuid = require(&apos;uuid&apos;)

const Context = require(&apos;./Context&apos;)

class SqliteContext extends Context {
  constructor (...args) {
    super(...args)

    // Currently only supporting in-memory databases but in
    // future will allow loading from project folder
    const path = uuid()
    this._db = new Database(path, {memory: true})

    // Attached in-memory databases for caching of cell inputs and outputs
    this._db.exec(&apos;ATTACH DATABASE &quot;:memory:&quot; AS inputs&apos;)
    this._db.exec(&apos;ATTACH DATABASE &quot;:memory:&quot; AS outputs&apos;)
  }

  /**
   * Get a list of outputs available from this context
   */
  async outputs () {
    return this._db.prepare(&apos;SELECT name FROM outputs.sqlite_master WHERE type==&quot;table&quot; AND name NOT LIKE &quot;tmp%&quot;&apos;).pluck().all()
  }

  /**
   * Resolve an output value
   *
   * @override
   */
  async resolve (what) {
    const name = what.name
    const rows = this._db.prepare(`SELECT count(*) FROM outputs.sqlite_master WHERE type==&quot;table&quot; AND name==&quot;${name}&quot;`).pluck().get()
    if (rows === 1) {
      return {
        local: true,
        table: `outputs.${name}`
      }
    } else {
      throw new Error(&apos;Could not find output pointed to: &apos; + name)
    }
  }

  /**
   * An override to provide the caller an output value
   * (in this context&apos;s case, a database table) as a
   * data package
   *
   * @override
   */
  async provide (what) {
    let sql = `SELECT * FROM outputs.${what.name}`
    if (what.limit) sql += ` LIMIT ${what.limit}`
    let rows = this._db.prepare(sql).all()

    let data = {}
    if (rows.length &gt; 0) {
      let fields = Object.keys(rows[0])

      for (let field of fields) {
        data[field] = []
      }
      for (let row of rows) {
        for (let field of fields) {
          data[field].push(row[field])
        }
      }
    }

    return this.pack({type: &apos;table&apos;, data})
  }

  /**
   * Compile a cell
   *
   * For a cell with `expr=true`, checks that the node consists of a single `SELECT` statement. That is, multiple `SELECT` statements,
   * or other types of SQL statements, e.g `UPDATE`, `DELETE`, are invalid.
   *
   * Parses SQL to determine the `inputs` property of the node including variable interpolations and tables
   * e.g. `SELECT * FROM data WHERE height &gt; ${min_height}` creates the inputs `[&quot;min_height&quot;, &quot;data&quot;]`.
   * Note that if a table already exists in the database then it is not included in `inputs` since it does
   * not need to be provided by the execution engine
   *
   * For `expr=false` (block) nodes determines if there is an output
   * e.g `low_gravity_planets` in `low_gravity_planets = SELECT * FROM planets WHERE gravity &lt;= 1`
   *
   * Checks for any statements that may cause side effects e.g `DELETE` or `CREATE TABLE` statements
   *
   * @override
   */
  async compile (cell, expr = false) {
    try {
      if (typeof cell === &apos;string&apos; || cell instanceof String) {
        cell = {
          source: {
            type: &apos;text&apos;,
            lang: &apos;sql&apos;,
            data: cell
          }
        }
      }
      if (!cell.type) cell.type = &apos;cell&apos;
      if (!cell.source) cell.source = {type: &apos;text&apos;, data: &apos;&apos;}
      if (!cell.expr) cell.expr = expr
      if (!cell.global) cell.global = false
      if (!cell.inputs) cell.inputs = []
      if (!cell.outputs) cell.outputs = []

      // Start with empty messages
      cell.messages = []

      if (cell.source.lang) {
        assert.ok(cell.source.lang.match(`^sql|sqlite$`), &apos;Cell `source.lang` property must be either &quot;sql&quot; or &quot;sqlite&quot;&apos;)
      }

      let sql = cell.source.data
      let outputName
      if (!cell.expr) {
        let trans = this._transpileSql(sql)
        sql = trans.sql
        outputName = trans.output
      }
      let interp = this._interpolateSql(sql)
      sql = interp.sql

      const ast = sqliteParser(sql)
      assert(ast, &apos;Cell source could not be parsed&apos;)

      if (cell.expr) {
        // Check that the AST is a single, SELECT statement
        assert(ast.statement.length === 1, &apos;Cell source must be a single &quot;SELECT&quot; statement&apos;)
        assert(ast.statement[0].variant === &apos;select&apos;, `Cell source must be a &quot;SELECT&quot; statement, &quot;${ast.statement[0].variant.toUpperCase()}&quot; not allowed`)
      } else {
        // Check the AST for side effects
        if (!cell.global) {
          const effects = []
          const search = (object) =&gt; {
            if (object.type === &apos;statement&apos; &amp;&amp; (object.variant !== &apos;list&apos; &amp;&amp; object.variant !== &apos;select&apos;)) {
              effects.push(object.variant.toUpperCase())
            } else if (typeof object === &apos;object&apos;) {
              for (const property of Object.values(object)) {
                search(property)
              }
            }
          }
          search(ast)
          assert(effects.length === 0, `Cell has potential side effects caused by using &quot;${effects.join(&apos;, &apos;)}&quot; statements`)
        }
      }

      const tables = this._tableInputs(ast)

      // Set the cell&apos;s inputs and output
      let inputNames = interp.variables.concat(tables).sort()
      let inputs = []
      for (let name of inputNames) {
        let input = {name}
        for (let current of cell.inputs) {
          if (current.name === name &amp;&amp; current.value) {
            input.value = current.value
            break
          }
        }
        inputs.push(input)
      }
      cell.inputs = inputs

      if (outputName) cell.outputs.push({name: outputName})

      return cell
    } catch (error) {
      return this._appendError(cell, error)
    }
  }

  /**
   * Execute a cell
   *
   * @override
   */
  async execute (cell, expr = false) {
    try {
      cell = await this.compile(cell, expr)

      // Unpack inputs in parrallel (some may be remote pointers) and reduce to an object
      let unpacked = await Promise.all(cell.inputs.map(input =&gt; this._unpack(input)))
      let inputs = unpacked.reduce((result, input) =&gt; {
        result[input.name] = input.value
        return result
      }, {})

      let sql = cell.source.data
      if (!cell.expr) {
        sql = this._transpileSql(sql).sql
      }
      sql = this._interpolateSql(sql, inputs).sql

      // Create temporary views to input tables
      for (let [name, value] of Object.entries(inputs)) {
        if (value &amp;&amp; value.table) {
          this._db.exec(`CREATE TEMPORARY VIEW ${name} AS SELECT * FROM ${value.table}`)
        }
      }

      let valueSql
      if (cell.expr) {
        // Output value of expression is just the expression
        valueSql = sql
      } else {
        // Split SQL into statements and run each
        let statements = sql.trim().split(&apos;;&apos;).filter(stmt =&gt; stmt.length &gt; 0)
        for (let statement of statements.slice(0, -1)) {
          let prepared = this._db.prepare(statement)
          // Ignore all select statements except for the last one
          if (prepared.returnsData) {
            cell.messages.push({
              type: &apos;warning&apos;,
              message: &apos;Ignored a SELECT statement that is before the last statement&apos;
            })
          } else {
            prepared.run()
          }
        }
        // Output value of block is last statement
        valueSql = statements[statements.length - 1]
      }

      let name
      if (cell.outputs[0]) name = cell.outputs[0].name
      let value = await this._pack(name, valueSql, cell)
      let output = {}
      if (name) output.name = name
      if (value) output.value = value
      cell.outputs = [output]

      // Destroy views to input tables
      for (let [name, value] of Object.entries(inputs)) {
        if (value &amp;&amp; value.table) {
          this._db.exec(`DROP VIEW IF EXISTS ${name}`)
        }
      }

      return cell
    } catch (error) {
      return this._appendError(cell, error)
    }
  }

  /**
   * Transpile SQL removing any `output = SELECT ...` extensions and
   * returning the output names
   */
  _transpileSql (sql) {
    let outputs = []
    sql = sql.replace(/^(\s*(\w+)\s*=\s*)\b(SELECT\b.+)/img, function (match, group1, group2, group3) {
      outputs.push({
        name: group2,
        expr: group3
      })
      // Insert spaces so that error reporting location is correct
      return &apos; &apos;.repeat(group1.length) + group3
    })
    let output = null
    if (outputs.length === 1) {
      output = outputs[0].name
    } else if (outputs.length &gt; 1) {
      let names = outputs.map(output =&gt; output.name).join(&apos;, &apos;)
      throw new Error(`Cell must have only one output but ${outputs.length} found &quot;${names}&quot;`)
    }
    return {output, sql}
  }

  /**
   * Do string interpolation of variables in SQL code
   *
   * @param  {String} sql SQL code with interpolation marks e.g. `SELECT * FROM data WHERE height &gt; ${x} AND width &lt; ${y}`
   * @return {Object}     Interpolation variable names and interpolated e.g. `{variables:[&apos;x&apos;, &apos;y&apos;], sql: &apos;SELECT * FROM data WHERE height &gt; 10 AND width &lt; 32&apos;}`
   */
  _interpolateSql (sql, inputs = {}) {
    let variables = []
    sql = sql.replace(/\${([^{}]*)}/g, function (match, name) {
      variables.push(name)
      return inputs[name] || &apos;0&apos;
    })
    return {variables, sql}
  }

  /**
   * Get table inputs by filtering the AST but exclude those tables that already exist in the database
   *
   * @param  {AST}    ast SQL AST
   * @return {Array}      A list of tables that are inputs into the SQL statement/s
   */
  _tableInputs (ast) {
    let rows = this._db.prepare(&apos;SELECT name FROM sqlite_master WHERE type==&quot;table&quot;&apos;).all()
    const existing = rows.map(row =&gt; row.name)

    const tables = []
    const search = (object) =&gt; {
      if (object.type === &apos;identifier&apos; &amp;&amp; object.variant === &apos;table&apos;) {
        if (existing.indexOf(object.name) &lt; 0) tables.push(object.name)
      } else if (typeof object === &apos;object&apos;) {
        for (const property of Object.values(object)) {
          search(property)
        }
      }
    }
    search(ast.statement[0])

    return tables
  }

  /**
   * Unpack an input `{name, value}` object
   *
   * @param  {Object} input Input object
   * @return {Object}       Object with name and unpacked value `{name, value}`
   */
  async _unpack (input) {
    let {name, value: packed} = input
    if (!packed) return {name} // Input may have not been provided. Deal with better?
    if (packed.type === &apos;table&apos;) {
      let table
      if (packed.data) {
        table = packed.data
      } else {
        table = await this.unpackPointer(packed)
        if (table.local) {
          return {name, value: {table: table.table}}
        }
      }
      // Create a table for this input
      let data = table.data
      let cols = Object.keys(data)
      let rows = data[cols[0]].length
      this._db.exec(`DROP TABLE IF EXISTS inputs.${name}`)
      this._db.exec(`CREATE TABLE inputs.${name} (${cols.join(&apos;, &apos;)})`)
      let statement = this._db.prepare(`INSERT INTO ${name} VALUES (${Array(cols.length).fill(&apos;?&apos;).join(&apos;,&apos;)})`)
      for (let row = 0; row &lt; rows; row++) {
        let rowData = []
        for (let col of cols) rowData.push(data[col][row])
        statement.run(rowData)
      }
      return {name, value: {table: `inputs.${name}`}}
    } else {
      return {name, value: await this.unpack(packed)}
    }
  }

  async _pack (name, select, node) {
    if (!name) name = &apos;tmp&apos; + crypto.randomBytes(12).toString(&apos;hex&apos;)

    this._db.exec(`DROP TABLE IF EXISTS outputs.${name}`)
    this._db.exec(`CREATE TABLE outputs.${name} AS ${select}`)

    const MAX_ROWS = 10
    let pkg = await this.provide({name, limit: MAX_ROWS})

    // Decide to create a package or a data pointer
    let rowNum = this._db.prepare(`SELECT count(*) FROM outputs.${name}`).pluck().get()
    if (rowNum &lt;= MAX_ROWS) {
      return pkg
    } else {
      return this.packPointer({type: &apos;table&apos;, name, preview: pkg.data})
    }
  }

  /**
   * Handle an error when compiling or executing a node
   * including dealing with error locations
   */
  _appendError (node, error) {
    let message = {
      type: &apos;error&apos;,
      message: error.message,
      stack: error.stack
    }
    if (error.location) {
      message.line = error.location.start.line - 1
      message.column = error.location.start.column - 1
    }
    if (!node.messages) node.messages = []
    node.messages.push(message)
    return node
  }
}

SqliteContext.spec = {
  name: &apos;SqliteContext&apos;,
  client: &apos;ContextHttpClient&apos;
}

module.exports = SqliteContext
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
