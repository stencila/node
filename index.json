[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "lib/contexts/Context.js",
    "content": "const uuid = require('uuid')\nconst request = require('request-promise')\n\nclass Context {\n  constructor (host, name) {\n    this._host = host\n    this._id = `node-${this.constructor.name.toLowerCase()}-${uuid()}`\n    this._name = name\n    this._variables = {}\n  }\n\n  get host () {\n    return this._host\n  }\n\n  get id () {\n    return this._id\n  }\n\n  get name () {\n    return this._name\n  }\n\n  get location () {\n    return {\n      context: {\n        id: this._id,\n        name: this._name\n      },\n      host: {\n        id: this._host.id,\n        port: this._host.servers.http && this._host.servers.http.port\n      },\n      machine: {\n        id: this._host.machine.id,\n        ip: this._host.machine.ip\n      }\n    }\n  }\n\n  async libraries () {\n    return {}\n  }\n\n  async pack (value) {\n    return this.packPackage(value)\n  }\n\n  /**\n   * Unpack a data node into a native data value\n   *\n   * @param  {Object} node A data node (either a data packet or data pointer)\n   * @return {[type]}      [description]\n   */\n  async unpack (node) {\n    return this.unpackPackage(node)\n  }\n\n  async packPackage (value) {\n    let type\n    if (value === null) type = 'null'\n    else type = value.type || typeof value\n    switch (type) {\n      case 'image':\n        return {type, src: value.src}\n      default:\n        return {type, data: value}\n    }\n  }\n\n  async unpackPackage (pkg) {\n    const type = pkg.type\n    switch (type) {\n      default: return pkg.data\n    }\n  }\n\n  async packPointer ({type, name, preview = null}) {\n    let {context, host, machine} = this.location\n    return {\n      type,\n      path: {\n        value: {\n          id: 'value-' + uuid(),\n          name: name\n        },\n        context,\n        host,\n        machine\n      },\n      preview: preview\n    }\n  }\n\n  async unpackPointer (pointer) {\n    const path = pointer.path\n    const what = {\n      name: path.value.name\n    }\n    if (path.context.id === this.id) {\n      // Get data from this context\n      return this.resolve(what)\n    } else if (path.host.id === this.host.id) {\n      // Get a context on this host to provide data\n      let context = await this.host.resolve(path.context.name)\n      let packag = await context.provide(what)\n      return this.unpack(packag)\n    } else if (path.machine.id === this.host.machine.id) {\n      // Make a HTTP request to context via another host on this machine\n      return this.host.generateToken(path.host.id).then(token => {\n        const url = `http://127.0.0.1:${path.host.port}/${path.context.name}!provide`\n        const auth = 'Bearer ' + token\n        return request({\n          method: 'PUT',\n          uri: url,\n          headers: {\n            Accept: 'application/json',\n            Authorization: auth\n          },\n          body: what,\n          json: true\n        })\n      }).then(packag => {\n        return this.unpack(packag)\n      })\n    } else {\n      // Currently, because access keys are not exchanged between machines, this\n      // is not possible. It may be possible in the future.\n      throw new Error('Inter-machine pointers are not yet supported')\n    }\n  }\n\n  async resolve (what) {\n    if (!what.name) throw new Error('No name in: ' + what)\n    const value = this._variables[what.name]\n    if (value === undefined) throw new Error('No such value: ' + what.name)\n    return value\n  }\n\n  async provide (what) {\n    const data = await this.resolve(what)\n    return this.pack(data)\n  }\n\n  async compile (cell) {\n    let source\n    if (typeof cell === 'string' || cell instanceof String) {\n      source = cell\n    } else if (typeof cell === 'function') {\n      source = cell.toString()\n    } else {\n      source = cell.source.data\n    }\n\n    return {\n      source: {\n        type: 'string',\n        data: source\n      },\n      expr: cell.expr || false,\n      global: cell.global || false,\n      options: {},\n      inputs: [],\n      outputs: [],\n      messages: []\n    }\n  }\n\n  async execute (cell) {\n    return cell\n  }\n\n  async evaluate (node) {\n    switch (node.type) {\n      case 'get': return this.evaluateGet(node)\n      case 'call': return this.evaluateCall(node)\n      default: return this.unpack(node)\n    }\n  }\n}\n\nContext.spec = {\n  name: 'Context',\n  client: 'ContextHttpClient'\n}\n\nmodule.exports = Context\n",
    "static": true,
    "longname": "/home/travis/build/stencila/node/lib/contexts/Context.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "Context",
    "memberof": "lib/contexts/Context.js",
    "static": true,
    "longname": "lib/contexts/Context.js~Context",
    "access": "public",
    "export": true,
    "importPath": "stencila-node/lib/contexts/Context.js",
    "importStyle": "Context",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 5,
    "undocument": true
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "_host",
    "memberof": "lib/contexts/Context.js~Context",
    "static": false,
    "longname": "lib/contexts/Context.js~Context#_host",
    "access": "private",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "_id",
    "memberof": "lib/contexts/Context.js~Context",
    "static": false,
    "longname": "lib/contexts/Context.js~Context#_id",
    "access": "private",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "_name",
    "memberof": "lib/contexts/Context.js~Context",
    "static": false,
    "longname": "lib/contexts/Context.js~Context#_name",
    "access": "private",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "_variables",
    "memberof": "lib/contexts/Context.js~Context",
    "static": false,
    "longname": "lib/contexts/Context.js~Context#_variables",
    "access": "private",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "get",
    "name": "host",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#host",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "get",
    "name": "id",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#id",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 57,
    "kind": "get",
    "name": "name",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#name",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 58,
    "kind": "get",
    "name": "location",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#location",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "{\"context\": *, \"host\": *, \"machine\": *}"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "libraries",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#libraries",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "pack",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#pack",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "unpack",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#unpack",
    "access": "public",
    "description": "Unpack a data node into a native data value",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": "A data node (either a data packet or data pointer)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[type]"
      ],
      "spread": false,
      "description": "[description]"
    }
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "packPackage",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#packPackage",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"type\": *, \"data\": *}"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "unpackPackage",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#unpackPackage",
    "access": "public",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "params": [
      {
        "name": "pkg",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "packPointer",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#packPointer",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"type\": *, \"name\": *, \"preview\": *}"
        ],
        "defaultRaw": {
          "type": null,
          "name": null,
          "preview": null
        },
        "defaultValue": "{\"type\":null,\"name\":null,\"preview\":null}"
      }
    ],
    "return": {
      "types": [
        "{\"type\": *, \"path\": *, \"preview\": *}"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "unpackPointer",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#unpackPointer",
    "access": "public",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "params": [
      {
        "name": "pointer",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "resolve",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 133,
    "undocument": true,
    "params": [
      {
        "name": "what",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "provide",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#provide",
    "access": "public",
    "description": null,
    "lineNumber": 140,
    "undocument": true,
    "params": [
      {
        "name": "what",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "compile",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#compile",
    "access": "public",
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "params": [
      {
        "name": "cell",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"source\": *, \"expr\": *, \"global\": *, \"options\": *, \"inputs\": *, \"outputs\": *, \"messages\": *}"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "execute",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#execute",
    "access": "public",
    "description": null,
    "lineNumber": 169,
    "undocument": true,
    "params": [
      {
        "name": "cell",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "evaluate",
    "memberof": "lib/contexts/Context.js~Context",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/Context.js~Context#evaluate",
    "access": "public",
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "params": [
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "file",
    "name": "lib/contexts/JavascriptContext.js",
    "content": "const acorn = require('acorn')\nconst doctrine = require('doctrine')\nconst { generate } = require('astring')\nconst walk = require('acorn/dist/walk')\n\nconst Context = require('./Context')\n\n/**\n * Global variable names that should be ignored when determining\n * cell inputs with the `compile()` method\n *\n * @type {Array}\n */\nconst GLOBALS = [\n  // A list of ES6 globals obtained using: Object.keys(require('globals').es6)\n  'Array', 'ArrayBuffer', 'Boolean', 'constructor', 'DataView', 'Date', 'decodeURI', 'decodeURIComponent',\n  'encodeURI', 'encodeURIComponent', 'Error', 'escape', 'eval', 'EvalError', 'Float32Array', 'Float64Array',\n  'Function', 'hasOwnProperty', 'Infinity', 'Int16Array', 'Int32Array', 'Int8Array', 'isFinite', 'isNaN',\n  'isPrototypeOf', 'JSON', 'Map', 'Math', 'NaN', 'Number', 'Object', 'parseFloat', 'parseInt', 'Promise',\n  'propertyIsEnumerable', 'Proxy', 'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set', 'String',\n  'Symbol', 'SyntaxError', 'System', 'toLocaleString', 'toString', 'TypeError', 'Uint16Array', 'Uint32Array',\n  'Uint8Array', 'Uint8ClampedArray', 'undefined', 'unescape', 'URIError', 'valueOf', 'WeakMap', 'WeakSet',\n  // A list of Node.js globals obtained using: Object.keys(require('globals').node)\n  '__dirname', '__filename', 'arguments', 'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout', 'console',\n  'exports', 'GLOBAL', 'global', 'Intl', 'module', 'process', 'require', 'root', 'setImmediate', 'setInterval', 'setTimeout'\n]\n\n/**\n * An execution context for Javascript\n *\n * Although this currently resides in the `stencila/node` repository,\n * it is intended for eventual use within the browser by\n * replacing the `JsContext in `stencila/stencila`\n */\nclass JavascriptContext extends Context {\n  constructor (host, name) {\n    super(host, name)\n\n    /**\n     * Libraries registered in this context\n     *\n     * @type {Object}\n     */\n    this._libraries = {}\n\n    /**\n     * Variables residing in this context\n     *\n     * @type {Object}\n     */\n    this._variables = {}\n  }\n\n  /**\n   * Pack a value\n   *\n   * An overide of `Context.pack` which deals\n   * with packing of functions.\n   *\n   * @overide\n   */\n  async pack (value) {\n    if (typeof value === 'function') {\n      return {\n        type: 'function',\n        data: value._spec || {name: value.name},\n        location: this.location\n      }\n    } else {\n      return super.pack(value)\n    }\n  }\n\n  /**\n   * Get the libraries registered in this context\n   */\n  async libraries () {\n    return this._libraries\n  }\n\n  /**\n   * Get the variables residing in this context\n   */\n  async variables () {\n    let packed = {}\n    for (let [name, variable] of Object.entries(this._variables)) {\n      packed[name] = await this.pack(variable)\n    }\n    return packed\n  }\n\n  /**\n   * Compile a cell\n   */\n  async compile (cell, internal = false) {\n    // Cell source code\n    let source\n    if (typeof cell === 'string' || cell instanceof String) {\n      source = cell\n    } else if (typeof cell === 'function') {\n      source = cell.toString()\n    } else {\n      source = cell.source.data\n    }\n\n    // Should source be a simple expression?\n    const exprOnly = cell.expr || false\n\n    // Input values\n    let inputs = []\n\n    // Output name and value (currently assuming a single output)\n    let name\n    let value\n\n    // A code expression to execute to get the return value\n    // (only used internally as an optimisation when\n    // called by `this.execute()`)\n    let _return = null\n\n    // Error messages\n    let messages = []\n\n    // Parse the source code (including comments for function definitions)\n    let ast\n    let docs = []\n    try {\n      ast = acorn.parse(source, {\n        sourceType: 'module',\n        onComment: (block, text) => {\n          if (block) docs.push(text)\n        }\n      })\n    } catch (error) {\n      let line = 0\n      let column = 0\n      if (error instanceof SyntaxError && error.loc) {\n        line = error.loc.line\n        column = error.loc.column\n      }\n      messages.push({\n        type: 'error',\n        message: 'Syntax error in Javascript: ' + error.message,\n        line,\n        column\n      })\n    }\n    if (docs.length === 0) docs.push(null)\n\n    // Check for single expression only\n    // Only allow simple expressions\n    // See http://esprima.readthedocs.io/en/latest/syntax-tree-format.html#expressions-and-patterns\n    // for a list of expression types\n    if (messages.length === 0 && exprOnly) {\n      try {\n        if (ast.body.length > 1) throw new Error()\n        const first = ast.body[0]\n        if (!first) throw new Error()\n        if (first.type !== 'ExpressionStatement') throw new Error()\n        const dissallowed = ['AssignmentExpression', 'UpdateExpression', 'AwaitExpression', 'Super']\n        if (dissallowed.indexOf(first.expression.type) >= 0) throw new Error()\n      } catch (error) {\n        messages.push({\n          type: 'error',\n          message: 'Cell source code must be a single, simple Javascript expression'\n        })\n      }\n    }\n\n    if (messages.length === 0) {\n      // Determine which names are declared and which are used\n      // do not enter some nodes like blocks and function declarations\n      // because we only want to pick up top level declarations and\n      // identifers\n      let declared = []\n      walk.recursive(ast, {}, {\n        BlockStatement (node, state, contin) {},\n        // For statements contain variable declarations we wish to ignore\n        ForStatement (node, state, contin) {},\n        ForInStatement (node, state, contin) {},\n        ForOfStatement (node, state, contin) {},\n        FunctionDeclaration (node, state, contin) {\n          declared.push(node.id.name)\n        },\n        VariableDeclarator (node, state, contin) {\n          declared.push(node.id.name)\n          // Recurse into initializer\n          if (node.init) contin(node.init, state)\n        },\n        Identifier (node, state, contin) {\n          let name = node.name\n          if (declared.indexOf(name) < 0 && GLOBALS.indexOf(name) < 0) {\n            inputs.push({ name })\n          }\n        }\n      })\n\n      // If the last top level node in the AST is a FunctionDeclaration,\n      // VariableDeclaration or Identifier then use it's name as the output name\n      let last = ast.body.pop()\n      if (last) {\n        switch (last.type) {\n          case 'FunctionDeclaration':\n            name = last.id.name\n            value = this._compileFunction(name, last, source, docs)\n            _return = name\n            break\n          case 'ExportDefaultDeclaration':\n            // Currently, only handle exported functions\n            const decl = last.declaration\n            if (decl.type === 'FunctionDeclaration') {\n              name = decl.id.name\n              value = this._compileFunction(name, decl, source, docs)\n              _return = name\n            }\n            break\n          case 'VariableDeclaration':\n            name = last.declarations[0].id.name\n            _return = name\n            break\n          case 'ExpressionStatement':\n            if (last.expression.type === 'Identifier') {\n              // If the identifier is not in inputs then\n              // use it as the output name\n              const id = last.expression.name\n              if (inputs.filter(({name}) => name === id).length === 0) {\n                name = id\n              }\n            }\n            _return = generate(last)\n            break\n          case 'BlockStatement':\n          case 'IfStatement':\n            break\n          default:\n            // During development it can be useful to turn this on\n            throw new Error('Unhandled AST node type: ' + last.type)\n        }\n      }\n    }\n\n    let output = {}\n    if (name) output.name = name\n    if (value) output.value = await this.pack(value)\n    let outputs = (name || value || _return) ? [output] : []\n\n    const compiled = {\n      type: 'cell',\n      source: {\n        type: 'string',\n        data: source\n      },\n      inputs,\n      outputs,\n      messages\n    }\n    if (internal) compiled._return = _return\n\n    return compiled\n  }\n\n  _compileFunction (name, decl, source, docs) {\n    let func = {\n      type: 'function',\n      name: name\n    }\n\n    // Extract the type specification for a `@param` or `@return` tag\n    function _extractType (tag) {\n      switch (tag.type.type) {\n        case 'AllLiteral':\n          return 'any'\n        case 'NameExpression':\n          return tag.type.name\n        case 'UnionType':\n          return tag.type.elements.map((element) => element.name).join('|')\n        case 'TypeApplication':\n          return tag.type.expression.name + '[' +\n                 tag.type.applications.map((application) => application.name).join(',') + ']'\n        case 'OptionalType':\n          return tag.default ? tag.type.expression.name : 'null'\n        case 'RestType':\n          return tag.type.expression.name\n        default:\n          throw new Error('Unhandled type specification: ' + tag.type.type)\n      }\n    }\n\n    let methods = {}\n    for (let doc of docs) {\n      let method = {}\n      let params = []\n      let return_\n      let examples = []\n      if (doc) {\n        // Strip spaces and asterisks from front of each line\n        let jsdoc = doc.replace(/^\\s*\\*?/mg, '')\n        // Parse JSDoc documentation\n        const {description, tags} = doctrine.parse(jsdoc, {\n          sloppy: true // allow optional parameters to be specified in brackets\n        })\n        if (!func.description) func.description = description\n        else method.description = description\n        // Process tags\n        for (let tag of tags) {\n          switch (tag.title) {\n            // Tags which always apply to the function as a whole\n\n            case 'name':\n              if (tag.name !== name) throw new Error(`Documentation tag @name with name \"${tag.name}\" differs from name in function definition`)\n              break\n\n            case 'title':\n              func.title = tag.description\n              break\n\n            case 'summary':\n              func.summary = tag.description\n              break\n\n            case 'description':\n              func.description = tag.description\n              break\n\n            // Tags applied to indivdual methods\n\n            case 'param':\n              let param = {\n                name: tag.name || `par${params.length + 1}`\n              }\n              if (tag.type) {\n                if (tag.type.type === 'RestType') {\n                  param.type = _extractType(tag)\n                  param.repeats = true\n                } else if (tag.type.type === 'NameExpression' && tag.type.name.substring(0, 3) === '___') {\n                  param.type = tag.type.name.substring(3)\n                  param.extends = true\n                } else {\n                  param.type = _extractType(tag)\n                }\n              }\n              if (tag.description) param.description = tag.description\n              params.push(param)\n              break\n\n            case 'return':\n              return_ = {}\n              if (tag.type) return_.type = _extractType(tag)\n              if (tag.description) return_.description = tag.description\n              break\n\n            case 'example':\n              let example = {\n                usage: tag.description\n              }\n              if (tag.caption) example.caption = tag.caption\n              examples.push(example)\n              break\n          }\n        }\n      } else {\n        // Process each parameter declaration node into a parameter spec\n        for (let node of decl.params) {\n          let param = {}\n          switch (node.type) {\n            case 'Identifier':\n              if (node.name.substring(0, 3) === '___') {\n                param.name = node.name.substring(3)\n                param.extends = true\n              } else {\n                param.name = node.name\n              }\n              break\n            case 'RestElement':\n              param.name = node.argument.name\n              param.repeats = true\n              break\n            case 'AssignmentPattern':\n              param.name = node.left.name\n              param.default = source.substring(node.right.start, node.right.end)\n              break\n            default:\n              throw new Error(`Unhandled parameter node type \"${node.type}\"`)\n          }\n          params.push(param)\n        }\n      }\n\n      if (params.length || return_ || examples.length) {\n        let signature = name + '(' + params.map(param => {\n          return param.name + (param.type ? `: ${param.type}` : '')\n        }).join(', ') + ')'\n        if (return_) signature += `: ${return_.type}`\n        method.signature = signature\n\n        if (params.length) method.params = params\n        if (return_) method.return = return_\n        if (examples.length) method.examples = examples\n\n        methods[signature] = method\n      }\n    }\n\n    // Ensure that there is always at least one method\n    if (Object.values(methods).length === 0) {\n      let signature = name + '()'\n      methods[signature] = { signature }\n    }\n\n    func.methods = methods\n\n    return func\n  }\n\n  async execute (cell) {\n    // At present, the received cell may not have\n    // all the things we need (e.g. outputs etc) from a\n    // previous compilation step. So we compile the cell\n    // and extract those from there. Only `inputs` (with values)\n    // are taken from the received cell\n    let compiled = await this.compile(cell, true)\n    cell = {\n      source: compiled.source,\n      expr: cell.expr || false,\n      inputs: cell.inputs || [],\n      outputs: compiled.outputs,\n      messages: compiled.messages\n    }\n\n    // Get cell source code adding the return value of function to the code\n    // (i.e. simulate implicit return). Although this approach is inefficient,\n    // because it involves executing expressions twice, it\n    // has the advantage of accurately reporting errors in the correct location\n    // in the cell's source code. Other approaches can be investigated later.\n    let source = cell.source.data + `;\\nreturn ${compiled._return};`\n\n    // Get the names and values of cell inputs\n    let inputNames = []\n    let inputValues = []\n    for (let input of cell.inputs) {\n      let {name, value} = input\n      if (!name) throw new Error(`Name is required for input`)\n      if (!value) throw new Error(`Value is required for input \"${name}\"`)\n      inputNames.push(name)\n      // Get the input from variables, if available, otherwise\n      // unpack the provided one\n      let value_\n      if (this._variables.hasOwnProperty(name)) {\n        value_ = this._variables[name]\n      } else {\n        value_ = await this.unpack(value)\n      }\n      inputValues.push(value_)\n    }\n\n    // Construct a function from them\n    const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor\n    const func = new AsyncFunction(...inputNames, source) // eslint-disable-line no-new-func\n\n    // Execute the function, using input values as arguments\n    // an converting exceptions into error messages\n    let value\n    try {\n      value = await func(...inputValues)\n    } catch (error) {\n      let line = 0\n      let column = 0\n      let message\n      if (error.stack) {\n        // Parse the error stack to get message, line and columns numbers\n        let lines = error.stack.split('\\n')\n        let match = lines[1].match(/<anonymous>:(\\d+):(\\d+)/)\n        if (match) {\n          line = parseInt(match[1], 10) - 2\n          column = parseInt(match[2], 10)\n        }\n        message = lines[0] || error.message\n      }\n      cell.messages.push({\n        type: 'error',\n        line: line,\n        column: column,\n        message: message\n      })\n    }\n\n    const output = cell.outputs[0]\n    if (output) {\n      if (output.name) {\n        // Register the output as a variable residing in this context\n        this._variables[output.name] = value\n      }\n\n      if (typeof value === 'undefined') {\n        // If the cell has an output but that output is undefined\n        // then treat it as an error\n        cell.messages.push({\n          type: 'error',\n          message: 'Cell output value is undefined'\n        })\n      } else {\n        if (typeof value === 'function' && output.value && output.value.type === 'function') {\n          // Output value is a function, get it's specification\n          let func = await this.unpack(output.value)\n\n          // Attach the specification to the function object\n          value._spec = func\n\n          // Attach the function to the specification and\n          // register in the library (we may drop this in the future\n          // in favour of treating functions just like other variables)\n          func.body = value\n          if (!this._libraries['local']) this._libraries['local'] = {}\n          this._libraries['local'][func.name] = func\n        } else {\n          // Pack the output value\n          output.value = await this.pack(value)\n        }\n      }\n    }\n\n    return cell\n  }\n\n  async evaluateCall (call) {\n    // Get the function\n    const func = await this.evaluate(call.func)\n\n    // Currently, just use the first method\n    const method = Object.values(func.methods)[0]\n\n    // Using `method.params` specification, map the call's arguments onto the method's parameters\n    let args = []\n    let argsIndex = 0\n    let argsUsed = 0\n    let namedArgs\n    let namedArgsUsed = []\n    if (method.params) {\n      for (let param of method.params) {\n        if (param.repeats) {\n          // Put the remaining arguments into an array\n          let remaining = []\n          for (; argsIndex < call.args.length; argsIndex++) {\n            remaining.push(await this.evaluate(call.args[argsIndex]))\n            argsUsed++\n          }\n          args.push(remaining)\n          break\n        } else if (param.extends) {\n          // Put the remaining named arguments into an object\n          if (call.namedArgs) {\n            namedArgs = {}\n            for (let name of Object.keys(call.namedArgs)) {\n              if (namedArgsUsed.indexOf(name) < 0) {\n                namedArgs[name] = await this.evaluate(call.namedArgs[name])\n                namedArgsUsed.push(param.name)\n              }\n            }\n          }\n          break\n        } else {\n          // Get the argument for the parameter either by name or by index\n          let arg\n          if (call.namedArgs) {\n            arg = call.namedArgs[param.name]\n            if (arg) namedArgsUsed.push(param.name)\n          }\n          if (!arg && call.args) {\n            arg = call.args[argsIndex]\n            if (arg) argsUsed++\n          }\n          if (!arg && !param.default) {\n            throw new Error(`Function parameter \"${param.name}\" must be supplied`)\n          }\n          if (arg) args.push(await this.evaluate(arg))\n          else args.push(undefined)\n        }\n        argsIndex++\n      }\n    }\n    // Check that there are no extra, unused arguments in call\n    if (call.args && argsUsed < call.args.length) {\n      const extra = call.args.length - argsUsed\n      throw new Error(`Function was supplied ${extra} extra arguments`)\n    }\n    if (call.namedArgs && namedArgsUsed.length < Object.keys(call.namedArgs).length) {\n      const extra = Object.keys(call.namedArgs).filter((arg) => namedArgsUsed.indexOf(arg) < 0)\n        .map((arg) => `\"${arg}\"`)\n        .join(', ')\n      throw new Error(`Function was supplied extra named arguments ${extra}`)\n    }\n    // Execute the actual function call\n    let value = namedArgs ? func.body(...args, namedArgs) : func.body(...args)\n    if (value !== undefined) call.value = await this.pack(value)\n\n    return call\n  }\n\n  async evaluateGet (get) {\n    // Currently, this just iterates over registered libraries looking\n    // for a value with the name\n    let value\n    for (let library of Object.values(this._libraries)) {\n      value = library[get.name]\n      if (value) break\n    }\n    if (!value) throw new Error(`Could not get value \"${get.name}\"`)\n    return value\n  }\n}\n\nJavascriptContext.spec = {\n  name: 'JavascriptContext',\n  client: 'ContextHttpClient'\n}\n\nmodule.exports = JavascriptContext\n",
    "static": true,
    "longname": "/home/travis/build/stencila/node/lib/contexts/JavascriptContext.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 72,
    "kind": "variable",
    "name": "GLOBALS",
    "memberof": "lib/contexts/JavascriptContext.js",
    "static": true,
    "longname": "lib/contexts/JavascriptContext.js~GLOBALS",
    "access": "public",
    "export": false,
    "importPath": "stencila-node/lib/contexts/JavascriptContext.js",
    "importStyle": null,
    "description": "Global variable names that should be ignored when determining\ncell inputs with the `compile()` method",
    "lineNumber": 14,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 73,
    "kind": "class",
    "name": "JavascriptContext",
    "memberof": "lib/contexts/JavascriptContext.js",
    "static": true,
    "longname": "lib/contexts/JavascriptContext.js~JavascriptContext",
    "access": "public",
    "export": true,
    "importPath": "stencila-node/lib/contexts/JavascriptContext.js",
    "importStyle": "JavascriptContext",
    "description": "An execution context for Javascript\n\nAlthough this currently resides in the `stencila/node` repository,\nit is intended for eventual use within the browser by\nreplacing the `JsContext in `stencila/stencila`",
    "lineNumber": 35,
    "interface": false,
    "extends": [
      "lib/contexts/Context.js~Context"
    ]
  },
  {
    "__docId__": 74,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/contexts/JavascriptContext.js~JavascriptContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/JavascriptContext.js~JavascriptContext#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "_libraries",
    "memberof": "lib/contexts/JavascriptContext.js~JavascriptContext",
    "static": false,
    "longname": "lib/contexts/JavascriptContext.js~JavascriptContext#_libraries",
    "access": "private",
    "description": "Libraries registered in this context",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 76,
    "kind": "member",
    "name": "_variables",
    "memberof": "lib/contexts/JavascriptContext.js~JavascriptContext",
    "static": false,
    "longname": "lib/contexts/JavascriptContext.js~JavascriptContext#_variables",
    "access": "private",
    "description": "Variables residing in this context",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "pack",
    "memberof": "lib/contexts/JavascriptContext.js~JavascriptContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/JavascriptContext.js~JavascriptContext#pack",
    "access": "public",
    "description": "Pack a value\n\nAn overide of `Context.pack` which deals\nwith packing of functions.",
    "lineNumber": 62,
    "unknown": [
      {
        "tagName": "@overide",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "libraries",
    "memberof": "lib/contexts/JavascriptContext.js~JavascriptContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/JavascriptContext.js~JavascriptContext#libraries",
    "access": "public",
    "description": "Get the libraries registered in this context",
    "lineNumber": 77,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "variables",
    "memberof": "lib/contexts/JavascriptContext.js~JavascriptContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/JavascriptContext.js~JavascriptContext#variables",
    "access": "public",
    "description": "Get the variables residing in this context",
    "lineNumber": 84,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "compile",
    "memberof": "lib/contexts/JavascriptContext.js~JavascriptContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/JavascriptContext.js~JavascriptContext#compile",
    "access": "public",
    "description": "Compile a cell",
    "lineNumber": 95,
    "params": [
      {
        "name": "cell",
        "types": [
          "*"
        ]
      },
      {
        "name": "internal",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": false,
        "defaultValue": "false"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "_compileFunction",
    "memberof": "lib/contexts/JavascriptContext.js~JavascriptContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/JavascriptContext.js~JavascriptContext#_compileFunction",
    "access": "private",
    "description": null,
    "lineNumber": 262,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "decl",
        "types": [
          "*"
        ]
      },
      {
        "name": "source",
        "types": [
          "*"
        ]
      },
      {
        "name": "docs",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "execute",
    "memberof": "lib/contexts/JavascriptContext.js~JavascriptContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/JavascriptContext.js~JavascriptContext#execute",
    "access": "public",
    "description": null,
    "lineNumber": 415,
    "undocument": true,
    "params": [
      {
        "name": "cell",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "evaluateCall",
    "memberof": "lib/contexts/JavascriptContext.js~JavascriptContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/JavascriptContext.js~JavascriptContext#evaluateCall",
    "access": "public",
    "description": null,
    "lineNumber": 525,
    "undocument": true,
    "params": [
      {
        "name": "call",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "evaluateGet",
    "memberof": "lib/contexts/JavascriptContext.js~JavascriptContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/JavascriptContext.js~JavascriptContext#evaluateGet",
    "access": "public",
    "description": null,
    "lineNumber": 599,
    "undocument": true,
    "params": [
      {
        "name": "get",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "file",
    "name": "lib/contexts/JupyterContext.js",
    "content": "const fs = require('fs')\nconst jmp = require('jmp')\nconst kernelspecs = require('kernelspecs')\nconst spawnteract = require('spawnteract')\nconst uuid = require('uuid')\n\nconst Context = require('./Context')\n\n/**\n * An execution context using Jupyter kernels\n *\n * This class of execution context acts as a bridge between Stencila and\n * Jupyter kernels. It exposes methods of the Stencila `Context` API e.g. `executeEval`\n * which delegate execution to a Jupyter kernel. This is done via the\n * [Jupyter Messageing Protocol (JMP)](http://jupyter-client.readthedocs.io/en/stable/messaging.html)\n * over [ZeroMQ](http://zeromq.org/) sockets.\n *\n * The `discover` static method should be called initially to find all Jupyter kernels\n * currently installed on the machine and update `JupyterContext.spec.kernels`:\n *\n *     JupyterContext.discover()\n *\n * New Jupyter execution contexts can be constructed using the `language` option which will\n * search for a kernel with a matching lowercased `language` property:\n *\n *     new JupyterContext({language:'r'})\n *\n * Alternively, you can specify a kernel directly:\n *\n *     new JupyterContext({kernel:'ir'})\n *\n * See https://github.com/jupyter/jupyter/wiki/Jupyter-kernels for a list of available\n * Jupyter kernels.\n *\n * Many thanks to the nteract community for [`kernelspecs`](https://github.com/nteract/kernelspecs) and\n * [`spawnteract`](https://github.com/nteract/spawnteract), and to Nicolas Riesco for (`jmp`)[https://github.com/n-riesco/jmp],\n * all of which made this implementation far easier!\n */\nclass JupyterContext extends Context {\n  /**\n   * Discover Jupyter kernels on the current machine\n   *\n   * Looks for Jupyter kernels that have been installed on the system\n   * and puts that list in `JupyterContext.spec.kernels` so that\n   * peers know the capabilities of this \"meta-context\".\n   *\n   * @return {Promise} A promise\n   */\n  static discover () {\n    // Create a list of kernel names and aliases\n    return kernelspecs.findAll().then(kernelspecs => {\n      JupyterContext.spec.kernels = kernelspecs\n    })\n  }\n\n  /**\n   * Construct a Jupyter execution context\n   *\n   * @param  {Object} options Options for specifying which kernel to use\n   */\n  constructor (host, name, options = {}) {\n    super(host, name)\n\n    let kernel = options.kernel\n    let kernelName = options.name\n    const kernels = JupyterContext.spec.kernels\n    const kernelNames = Object.keys(kernels)\n\n    if (!kernelNames.length) {\n      throw new Error('No Jupyter kernels available on this machine')\n    }\n    if (kernel && !kernels[kernel]) {\n      throw new Error(`Jupyter kernel \"${kernel}\" not available on this machine`)\n    }\n    if (kernelName) {\n      for (let spec of kernels) {\n        if (spec.name.toLowerCase() === kernelName) {\n          kernel = spec.name\n          break\n        }\n      }\n      if (!kernel) {\n        throw new Error(`No Jupyter kernel on this machine with name \"${kernelName}\"`)\n      }\n    }\n    if (!kernel) {\n      if (kernelNames.indexOf('python3') >= 0) kernel = 'python3'\n      else kernel = kernelNames[0]\n    }\n    this.kernel = kernel\n\n    this.debug = options.debug || false\n    this.timeout = options.timeout || -1\n  }\n\n  /**\n   * Initialize the context\n   *\n   * @return {Promise} A promise\n   */\n  initialize () {\n    if (this._process) return Promise.resolve()\n    else {\n      // Options to [child_process.spawn]{@link https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options}\n      let options = {}\n      // Pass `kernels` to `launch()` as an optimization to prevent another kernelspecs search of filesystem\n      return spawnteract.launch(this.kernel, options, JupyterContext.spec.kernels).then(kernel => {\n        this._process = kernel.spawn // The running process, from child_process.spawn(...)\n        this._connectionFile = kernel.connectionFile // Connection file path\n        this._config = kernel.config // Connection information from the file\n        this._spec = kernel.kernelSpec\n\n        // Unique session id for requests\n        this._sessionId = uuid()\n\n        // Map of requests for handling response messages\n        this._requests = {}\n\n        const origin = this._config.transport + '://' + this._config.ip\n\n        // Shell socket for execute, and other, request\n        this._shellSocket = new jmp.Socket('dealer', 'sha256', this._config.key)\n        this._shellSocket.connect(origin + ':' + this._config.shell_port)\n        this._shellSocket.on('message', this._response.bind(this))\n\n        // IOPub socket for receiving updates\n        this._ioSocket = new jmp.Socket('sub', 'sha256', this._config.key)\n        this._ioSocket.connect(origin + ':' + this._config.iopub_port)\n        this._ioSocket.on('message', this._response.bind(this))\n        this._ioSocket.subscribe('') // Subscribe to all topics\n\n        // Get kernel info mainly to confirm communication with kernel is\n        // working\n        return this._request('kernel_info_request', {}, ['kernel_info_reply']).then(({request, response}) => {\n          this._kernelInfo = response.content\n          // This wait seems to be necessary in order for messages to be received on\n          // `this._ioSocket`.\n          return new Promise((resolve, reject) => {\n            setTimeout(resolve, 1000)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Finalize the context\n   *\n   * @return {Promise} A resolved promise\n   */\n  finalize () {\n    if (this._shellSocket) {\n      this._shellSocket.removeAllListeners('message')\n      this._shellSocket.close()\n      this._shellSocket = null\n    }\n    if (this._ioSocket) {\n      this._ioSocket.removeAllListeners('message')\n      this._ioSocket.close()\n      this._ioSocket = null\n    }\n    if (this._process) {\n      this._process.kill()\n      this._process = null\n    }\n    if (this._connectionFile) {\n      fs.unlinkSync(this._connectionFile)\n      this._connectionFile = null\n    }\n    this._config = null\n    this._spec = null\n    return Promise.resolve()\n  }\n\n  /**\n   * Execute a cell\n   *\n   * For cells with `expr: true` utilises `user_expressions` property of an `execute_request` to\n   * evaluate expression side-effect free.\n   *\n   * @override\n   */\n  async execute (cell) {\n    // Compile the cell so it has correct structure\n    cell = await this.compile(cell)\n\n    // For expression cells, use `user_expressions`, not `code`\n    // to ensure there are no side effects (?)\n    let code\n    let expressions\n    if (cell.expr) {\n      code = ''\n      expressions = {\n        'value': cell.source.data\n      }\n    } else {\n      code = cell.source.data\n      expressions = {}\n    }\n\n    let content = {\n      // Source code to be executed by the kernel, one or more lines.\n      'code': code,\n\n      // A boolean flag which, if True, signals the kernel to execute\n      // this code as quietly as possible.\n      // silent=True forces store_history to be False,\n      // and will *not*:\n      //   - broadcast output on the IOPUB channel\n      //   - have an execute_result\n      // The default is False.\n      'silent': false,\n\n      // A boolean flag which, if True, signals the kernel to populate history\n      // The default is True if silent is False.  If silent is True, store_history\n      // is forced to be False.\n      'store_history': true,\n\n      // A dict mapping names to expressions to be evaluated in the\n      // user's dict. The rich display-data representation of each will be evaluated after execution.\n      // See the display_data content for the structure of the representation data.\n      'user_expressions': expressions,\n\n      // Some frontends do not support stdin requests.\n      // If this is true, code running in the kernel can prompt the user for input\n      // with an input_request message (see below). If it is false, the kernel\n      // should not send these messages.\n      'allow_stdin': false,\n\n      // A boolean flag, which, if True, does not abort the execution queue, if an exception is encountered.\n      // This allows the queued execution of multiple execute_requests, even if they generate exceptions.\n      'stop_on_error': false\n    }\n    return this._request('execute_request', content).then(({request, response}) => {\n      const msgType = response.header.msg_type\n      switch (msgType) {\n        case 'execute_result':\n        case 'display_data':\n          // Success! Unbundle the execution result, insert it into cell\n          // outputs and then return the cell\n          return this._unbundle(response.content.data).then(value => {\n            cell.outputs.push({value})\n            return cell\n          })\n        case 'execute_reply':\n          // We get  `execute_reply` messages when there is no\n          // execution result (e.g. an assignment), or when evaluating\n          // a user expression\n          const result = response.content.user_expressions.value\n          if (result) {\n            if (result.status === 'ok') {\n              return this._unbundle(result.data).then(value => {\n                cell.outputs.push({value})\n                return cell\n              })\n            } else if (result && result.status === 'error') {\n              cell.messages.push({\n                type: 'error',\n                message: result.ename + ': ' + result.evalue\n              })\n              return cell\n            }\n          } else {\n            return cell\n          }\n          break\n        case 'error':\n          // Errrror :( Add an error message to the cell\n          const error = response.content\n          cell.messages.push({\n            type: 'error',\n            message: error.ename + ': ' + error.evalue\n          })\n          return cell\n        default:\n          if (this.debug) console.log(`Unhandled message type: ${msgType}`)\n      }\n    }).catch(error => {\n      // Some other error happened...\n      cell.messages.push({\n        type: 'error',\n        message: error.message\n      })\n      return cell\n    })\n  }\n\n  /**\n   * Send a request message to the kernal\n   *\n   * @private\n   * @param  {String} requestType  Type of request e.g. 'execute'\n   * @param  {Object} content      Content of message\n   * @param  {String} responseTypes Types of response message to resolve\n   * @returns {Promise} Promise resolving to the {request, response} messages\n   */\n  _request (requestType, content, responseTypes = ['execute_result', 'display_data', 'execute_reply', 'error']) {\n    return new Promise((resolve, reject) => {\n      var request = new jmp.Message()\n      request.idents = []\n      request.header = {\n        'msg_id': uuid(),\n        'username': 'user',\n        'session': this._sessionId,\n        'msg_type': requestType,\n        'version': '5.2'\n      }\n      request.parent_header = {}\n      request.metadata = {}\n      request.content = content\n\n      this._requests[request.header.msg_id] = {\n        request,\n        responseTypes,\n        handler: (response) => resolve({request, response})\n      }\n      this._shellSocket.send(request)\n\n      // If this request has not been handled before `timeout`\n      // throw an error\n      if (this.timeout >= 0) {\n        setTimeout(() => {\n          if (this._requests[request.header.msg_id]) {\n            reject(new Error('Request timed out'))\n          }\n        }, this.timeout * 1000)\n      }\n    })\n  }\n\n  /**\n   * Receive a response message from the kernel\n   *\n   * @private\n   * @param  {Message} response Response message\n   */\n  _response (response) {\n    const requestId = response.parent_header.msg_id\n    const responseType = response.header.msg_type\n    const request = this._requests[requestId]\n    if (this.debug) {\n      console.log('Response: ', requestId, responseType, response.content)\n    }\n    // First response matching the request, including response type\n    // calls handler\n    if (request && request.responseTypes.indexOf(responseType) > -1) {\n      request.handler(response)\n      delete this._requests[requestId]\n    }\n  }\n\n  /**\n   * Convert a \"MIME bundle\" within a JMP message (e.g. a `execute_result` or\n   * `display data` message) into a data node\n   * e.g. `{'text/plain': 'Hello'}` to `{type: 'string', data: 'Hello'}`\n   *\n   * @private\n   * @param  {Object} bundle A JMP MIME bundle\n   * @return {Promise}       Promise resolving to a data node\n   */\n  _unbundle (bundle) {\n    return Promise.resolve().then(() => {\n      const image = bundle['image/png']\n      if (image) {\n        return {\n          type: 'image',\n          src: 'data:image/png;base64,' + image\n        }\n      }\n\n      const text = bundle['text/plain']\n      if (text) {\n        // Attempt to parse to JSON\n        try {\n          return JSON.parse(text)\n        } catch (error) {\n          return text\n        }\n      }\n    }).then(value => {\n      return this.pack(value)\n    })\n  }\n}\n\nJupyterContext.spec = {\n  name: 'JupyterContext',\n  client: 'ContextHttpClient',\n  kernels: {} // Populated by JupyterContext.setup\n}\n\nmodule.exports = JupyterContext\n",
    "static": true,
    "longname": "/home/travis/build/stencila/node/lib/contexts/JupyterContext.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 86,
    "kind": "class",
    "name": "JupyterContext",
    "memberof": "lib/contexts/JupyterContext.js",
    "static": true,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext",
    "access": "public",
    "export": true,
    "importPath": "stencila-node/lib/contexts/JupyterContext.js",
    "importStyle": "JupyterContext",
    "description": "An execution context using Jupyter kernels\n\nThis class of execution context acts as a bridge between Stencila and\nJupyter kernels. It exposes methods of the Stencila `Context` API e.g. `executeEval`\nwhich delegate execution to a Jupyter kernel. This is done via the\n[Jupyter Messageing Protocol (JMP)](http://jupyter-client.readthedocs.io/en/stable/messaging.html)\nover [ZeroMQ](http://zeromq.org/) sockets.\n\nThe `discover` static method should be called initially to find all Jupyter kernels\ncurrently installed on the machine and update `JupyterContext.spec.kernels`:\n\n    JupyterContext.discover()\n\nNew Jupyter execution contexts can be constructed using the `language` option which will\nsearch for a kernel with a matching lowercased `language` property:\n\n    new JupyterContext({language:'r'})\n\nAlternively, you can specify a kernel directly:\n\n    new JupyterContext({kernel:'ir'})\n\nSee https://github.com/jupyter/jupyter/wiki/Jupyter-kernels for a list of available\nJupyter kernels.\n\nMany thanks to the nteract community for [`kernelspecs`](https://github.com/nteract/kernelspecs) and\n[`spawnteract`](https://github.com/nteract/spawnteract), and to Nicolas Riesco for (`jmp`)[https://github.com/n-riesco/jmp],\nall of which made this implementation far easier!",
    "lineNumber": 39,
    "interface": false,
    "extends": [
      "lib/contexts/Context.js~Context"
    ]
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "discover",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext.discover",
    "access": "public",
    "description": "Discover Jupyter kernels on the current machine\n\nLooks for Jupyter kernels that have been installed on the system\nand puts that list in `JupyterContext.spec.kernels` so that\npeers know the capabilities of this \"meta-context\".",
    "lineNumber": 49,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise"
    },
    "params": []
  },
  {
    "__docId__": 88,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#constructor",
    "access": "public",
    "description": "Construct a Jupyter execution context",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Options for specifying which kernel to use"
      }
    ]
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "kernel",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#kernel",
    "access": "public",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "debug",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#debug",
    "access": "public",
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "timeout",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#timeout",
    "access": "public",
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "initialize",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#initialize",
    "access": "public",
    "description": "Initialize the context",
    "lineNumber": 101,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise"
    },
    "params": []
  },
  {
    "__docId__": 93,
    "kind": "member",
    "name": "_process",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#_process",
    "access": "private",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "member",
    "name": "_connectionFile",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#_connectionFile",
    "access": "private",
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "member",
    "name": "_config",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#_config",
    "access": "private",
    "description": null,
    "lineNumber": 110,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "_spec",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#_spec",
    "access": "private",
    "description": null,
    "lineNumber": 111,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "member",
    "name": "_sessionId",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#_sessionId",
    "access": "private",
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "_requests",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#_requests",
    "access": "private",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "_shellSocket",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#_shellSocket",
    "access": "private",
    "description": null,
    "lineNumber": 122,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "_ioSocket",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#_ioSocket",
    "access": "private",
    "description": null,
    "lineNumber": 127,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "_kernelInfo",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#_kernelInfo",
    "access": "private",
    "description": null,
    "lineNumber": 135,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "method",
    "name": "finalize",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#finalize",
    "access": "public",
    "description": "Finalize the context",
    "lineNumber": 151,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A resolved promise"
    },
    "params": []
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "execute",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#execute",
    "access": "public",
    "description": "Execute a cell\n\nFor cells with `expr: true` utilises `user_expressions` property of an `execute_request` to\nevaluate expression side-effect free.",
    "lineNumber": 183,
    "override": true,
    "params": [
      {
        "name": "cell",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "_request",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#_request",
    "access": "private",
    "description": "Send a request message to the kernal",
    "lineNumber": 297,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Promise resolving to the {request, response} messages"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "requestType",
        "description": "Type of request e.g. 'execute'"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "content",
        "description": "Content of message"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "responseTypes",
        "description": "Types of response message to resolve"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise resolving to the {request, response} messages"
    }
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "_response",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#_response",
    "access": "private",
    "description": "Receive a response message from the kernel",
    "lineNumber": 337,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "response",
        "description": "Response message"
      }
    ],
    "return": null
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "_unbundle",
    "memberof": "lib/contexts/JupyterContext.js~JupyterContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/JupyterContext.js~JupyterContext#_unbundle",
    "access": "private",
    "description": "Convert a \"MIME bundle\" within a JMP message (e.g. a `execute_result` or\n`display data` message) into a data node\ne.g. `{'text/plain': 'Hello'}` to `{type: 'string', data: 'Hello'}`",
    "lineNumber": 361,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bundle",
        "description": "A JMP MIME bundle"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise resolving to a data node"
    }
  },
  {
    "__docId__": 113,
    "kind": "file",
    "name": "lib/contexts/NodeContext.js",
    "content": "const fs = require('fs')\nlet glob = require('glob')\nconst path = require('path')\nconst rollup = require('rollup')\nconst rollupUglify = require('rollup-plugin-uglify')\nconst tmp = require('tmp')\nconst untildify = require('untildify')\nconst util = require('util')\nglob = util.promisify(glob)\n\nconst JavascriptContext = require('./JavascriptContext')\n\n/**\n * A Node.js context for executing Javascript code\n */\nclass NodeContext extends JavascriptContext {\n  /**\n   * Compile a Javascript source code file\n   *\n   * @param  {String} file File path\n   * @return {Object}      Function object\n   */\n  async compileFile (file) {\n    let content = fs.readFileSync(file, 'utf8')\n    try {\n      return this.compile(content)\n    } catch (error) {\n      throw new Error(`Error compiling file \"${file}\": ` + error.message)\n    }\n  }\n\n  /**\n   * Compile a Stencila library so that it can be loaded either into\n   * a `NodeContext` or another `JavascriptContext` (e.g one embedded\n   * into a Stencila web or desktop interface).\n   *\n   * Creates a Javascript bundle which exports both function definitions and\n   * a function specification objects.\n   *\n   * @param {String} src Path to library folder\n   * @param {String} dest Destination\n   * @param {Boolean} minify Should the bundle be minified? (defaults to true)\n   */\n  async compileLibrary (library = {}) {\n    let src = library.src || '.'\n    let dest = library.dest\n    let minify = (library.minify === false) ? library.minify : true\n\n    src = path.resolve(untildify(src))\n    if (!dest) {\n      let file = path.basename(src)\n      if (minify) file += '.min'\n      file += '.js'\n      dest = path.join(src, file)\n    }\n\n    try {\n      fs.statSync(src)\n    } catch (error) {\n      throw new Error(`No such folder \"${src}\"`)\n    }\n\n    const name = library.name || path.basename(src)\n\n    let json\n    try {\n      json = fs.readFileSync(path.join(src, 'package.json'))\n    } catch (error) {\n      json = '{}'\n    }\n    const pkg = JSON.parse(json)\n\n    const pattern = path.join(src, 'funcs', '*.js')\n    const files = await glob(pattern, {ignore: '**/_*'})\n    if (files.length === 0) throw new Error(`No functions found matching pattern \"${pattern}\"`)\n\n    let funcs = {}\n    let index = `\n      export const type = 'library'\n      export const name = '${name}'\n      export let funcs = {}\n    `\n    for (let file of files) {\n      let cell\n      try {\n        cell = await this.compileFile(file, false)\n      } catch (error) {\n        throw new Error(`Error compiling file \"${file}\": ${error.message}`)\n      }\n      let func = cell.outputs[0].value.data\n      const name = func.name\n      funcs[name] = func\n\n      const json = JSON.stringify(func, null, '  ')\n      index += `import ${name}_ from '${file}'\\n`\n      index += `funcs['${name}'] = ${json}\\n`\n      index += `funcs['${name}'].body = ${name}_\\n\\n`\n    }\n\n    const indexPath = tmp.tmpNameSync()\n    fs.writeFileSync(indexPath, index)\n\n    const rollupConfig = pkg.rollup || {}\n\n    const plugins = []\n    if (minify) plugins.push(rollupUglify())\n\n    const bundle = await rollup.rollup({\n      input: indexPath,\n      plugins: plugins,\n      external: rollupConfig.external\n    })\n\n    await bundle.write({\n      format: 'umd',\n      name: rollupConfig.name || 'local',\n      file: dest,\n      globals: rollupConfig.globals\n    })\n\n    return {\n      type: 'library',\n      name: name,\n      funcs: funcs,\n      bundle: dest\n    }\n  }\n\n  async executeLibrary (library_) {\n    const library = await this.compileLibrary(library_)\n    library.module = require(library.bundle)\n    this._libraries[library.name] = library\n    return {\n      type: 'library',\n      name: library.name,\n      funcs: library.funcs\n    }\n  }\n}\n\nNodeContext.spec = {\n  name: 'NodeContext',\n  client: 'ContextHttpClient'\n}\n\nmodule.exports = NodeContext\n",
    "static": true,
    "longname": "/home/travis/build/stencila/node/lib/contexts/NodeContext.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 114,
    "kind": "class",
    "name": "NodeContext",
    "memberof": "lib/contexts/NodeContext.js",
    "static": true,
    "longname": "lib/contexts/NodeContext.js~NodeContext",
    "access": "public",
    "export": true,
    "importPath": "stencila-node/lib/contexts/NodeContext.js",
    "importStyle": "NodeContext",
    "description": "A Node.js context for executing Javascript code",
    "lineNumber": 16,
    "interface": false,
    "extends": [
      "lib/contexts/JavascriptContext.js~JavascriptContext"
    ]
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "compileFile",
    "memberof": "lib/contexts/NodeContext.js~NodeContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/NodeContext.js~NodeContext#compileFile",
    "access": "public",
    "description": "Compile a Javascript source code file",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "file",
        "description": "File path"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Function object"
    }
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "compileLibrary",
    "memberof": "lib/contexts/NodeContext.js~NodeContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/NodeContext.js~NodeContext#compileLibrary",
    "access": "public",
    "description": "Compile a Stencila library so that it can be loaded either into\na `NodeContext` or another `JavascriptContext` (e.g one embedded\ninto a Stencila web or desktop interface).\n\nCreates a Javascript bundle which exports both function definitions and\na function specification objects.",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "src",
        "description": "Path to library folder"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "dest",
        "description": "Destination"
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "minify",
        "description": "Should the bundle be minified? (defaults to true)"
      }
    ],
    "return": {
      "types": [
        "{\"type\": string, \"name\": *, \"funcs\": *, \"bundle\": *}"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "executeLibrary",
    "memberof": "lib/contexts/NodeContext.js~NodeContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/NodeContext.js~NodeContext#executeLibrary",
    "access": "public",
    "description": null,
    "lineNumber": 129,
    "undocument": true,
    "params": [
      {
        "name": "library_",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"type\": string, \"name\": *, \"funcs\": *}"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "file",
    "name": "lib/contexts/SqliteContext.js",
    "content": "const assert = require('assert')\nconst crypto = require('crypto')\nconst Database = require('better-sqlite3')\nconst sqliteParser = require('sqlite-parser')\nconst uuid = require('uuid')\n\nconst Context = require('./Context')\n\nclass SqliteContext extends Context {\n  constructor (...args) {\n    super(...args)\n\n    // Currently only supporting in-memory databases but in\n    // future will allow loading from project folder\n    const path = uuid()\n    this._db = new Database(path, {memory: true})\n\n    // Attached in-memory databases for caching of cell inputs and outputs\n    this._db.exec('ATTACH DATABASE \":memory:\" AS inputs')\n    this._db.exec('ATTACH DATABASE \":memory:\" AS outputs')\n  }\n\n  /**\n   * Get a list of outputs available from this context\n   */\n  async outputs () {\n    return this._db.prepare('SELECT name FROM outputs.sqlite_master WHERE type==\"table\" AND name NOT LIKE \"tmp%\"').pluck().all()\n  }\n\n  /**\n   * Resolve an output value\n   *\n   * @override\n   */\n  async resolve (what) {\n    const name = what.name\n    const rows = this._db.prepare(`SELECT count(*) FROM outputs.sqlite_master WHERE type==\"table\" AND name==\"${name}\"`).pluck().get()\n    if (rows === 1) {\n      return {\n        local: true,\n        table: `outputs.${name}`\n      }\n    } else {\n      throw new Error('Could not find output pointed to: ' + name)\n    }\n  }\n\n  /**\n   * An override to provide the caller an output value\n   * (in this context's case, a database table) as a\n   * data package\n   *\n   * @override\n   */\n  async provide (what) {\n    let sql = `SELECT * FROM outputs.${what.name}`\n    if (what.limit) sql += ` LIMIT ${what.limit}`\n    let rows = this._db.prepare(sql).all()\n\n    let data = {}\n    if (rows.length > 0) {\n      let fields = Object.keys(rows[0])\n\n      for (let field of fields) {\n        data[field] = []\n      }\n      for (let row of rows) {\n        for (let field of fields) {\n          data[field].push(row[field])\n        }\n      }\n    }\n\n    return this.pack({type: 'table', data})\n  }\n\n  /**\n   * Compile a cell\n   *\n   * For a cell with `expr=true`, checks that the node consists of a single `SELECT` statement. That is, multiple `SELECT` statements,\n   * or other types of SQL statements, e.g `UPDATE`, `DELETE`, are invalid.\n   *\n   * Parses SQL to determine the `inputs` property of the node including variable interpolations and tables\n   * e.g. `SELECT * FROM data WHERE height > ${min_height}` creates the inputs `[\"min_height\", \"data\"]`.\n   * Note that if a table already exists in the database then it is not included in `inputs` since it does\n   * not need to be provided by the execution engine\n   *\n   * For `expr=false` (block) nodes determines if there is an output\n   * e.g `low_gravity_planets` in `low_gravity_planets = SELECT * FROM planets WHERE gravity <= 1`\n   *\n   * Checks for any statements that may cause side effects e.g `DELETE` or `CREATE TABLE` statements\n   *\n   * @override\n   */\n  async compile (cell, expr = false) {\n    try {\n      if (typeof cell === 'string' || cell instanceof String) {\n        cell = {\n          source: {\n            type: 'text',\n            lang: 'sql',\n            data: cell\n          }\n        }\n      }\n      if (!cell.type) cell.type = 'cell'\n      if (!cell.source) cell.source = {type: 'text', data: ''}\n      if (!cell.expr) cell.expr = expr\n      if (!cell.global) cell.global = false\n      if (!cell.inputs) cell.inputs = []\n      if (!cell.outputs) cell.outputs = []\n\n      // Start with empty messages\n      cell.messages = []\n\n      if (cell.source.lang) {\n        assert.ok(cell.source.lang.match(`^sql|sqlite$`), 'Cell `source.lang` property must be either \"sql\" or \"sqlite\"')\n      }\n\n      let sql = cell.source.data\n      let outputName\n      if (!cell.expr) {\n        let trans = this._transpileSql(sql)\n        sql = trans.sql\n        outputName = trans.output\n      }\n      let interp = this._interpolateSql(sql)\n      sql = interp.sql\n\n      const ast = sqliteParser(sql)\n      assert(ast, 'Cell source could not be parsed')\n\n      if (cell.expr) {\n        // Check that the AST is a single, SELECT statement\n        assert(ast.statement.length === 1, 'Cell source must be a single \"SELECT\" statement')\n        assert(ast.statement[0].variant === 'select', `Cell source must be a \"SELECT\" statement, \"${ast.statement[0].variant.toUpperCase()}\" not allowed`)\n      } else {\n        // Check the AST for side effects\n        if (!cell.global) {\n          const effects = []\n          const search = (object) => {\n            if (object.type === 'statement' && (object.variant !== 'list' && object.variant !== 'select')) {\n              effects.push(object.variant.toUpperCase())\n            } else if (typeof object === 'object') {\n              for (const property of Object.values(object)) {\n                search(property)\n              }\n            }\n          }\n          search(ast)\n          assert(effects.length === 0, `Cell has potential side effects caused by using \"${effects.join(', ')}\" statements`)\n        }\n      }\n\n      const tables = this._tableInputs(ast)\n\n      // Set the cell's inputs and output\n      let inputNames = interp.variables.concat(tables).sort()\n      let inputs = []\n      for (let name of inputNames) {\n        let input = {name}\n        for (let current of cell.inputs) {\n          if (current.name === name && current.value) {\n            input.value = current.value\n            break\n          }\n        }\n        inputs.push(input)\n      }\n      cell.inputs = inputs\n\n      if (outputName) cell.outputs.push({name: outputName})\n\n      return cell\n    } catch (error) {\n      return this._appendError(cell, error)\n    }\n  }\n\n  /**\n   * Execute a cell\n   *\n   * @override\n   */\n  async execute (cell, expr = false) {\n    try {\n      cell = await this.compile(cell, expr)\n\n      // Unpack inputs in parrallel (some may be remote pointers) and reduce to an object\n      let unpacked = await Promise.all(cell.inputs.map(input => this._unpack(input)))\n      let inputs = unpacked.reduce((result, input) => {\n        result[input.name] = input.value\n        return result\n      }, {})\n\n      let sql = cell.source.data\n      if (!cell.expr) {\n        sql = this._transpileSql(sql).sql\n      }\n      sql = this._interpolateSql(sql, inputs).sql\n\n      // Create temporary views to input tables\n      for (let [name, value] of Object.entries(inputs)) {\n        if (value && value.table) {\n          this._db.exec(`CREATE TEMPORARY VIEW ${name} AS SELECT * FROM ${value.table}`)\n        }\n      }\n\n      let valueSql\n      if (cell.expr) {\n        // Output value of expression is just the expression\n        valueSql = sql\n      } else {\n        // Split SQL into statements and run each\n        let statements = sql.trim().split(';').filter(stmt => stmt.length > 0)\n        for (let statement of statements.slice(0, -1)) {\n          let prepared = this._db.prepare(statement)\n          // Ignore all select statements except for the last one\n          if (prepared.returnsData) {\n            cell.messages.push({\n              type: 'warning',\n              message: 'Ignored a SELECT statement that is before the last statement'\n            })\n          } else {\n            prepared.run()\n          }\n        }\n        // Output value of block is last statement\n        valueSql = statements[statements.length - 1]\n      }\n\n      let name\n      if (cell.outputs[0]) name = cell.outputs[0].name\n      let value = await this._pack(name, valueSql, cell)\n      let output = {}\n      if (name) output.name = name\n      if (value) output.value = value\n      cell.outputs = [output]\n\n      // Destroy views to input tables\n      for (let [name, value] of Object.entries(inputs)) {\n        if (value && value.table) {\n          this._db.exec(`DROP VIEW IF EXISTS ${name}`)\n        }\n      }\n\n      return cell\n    } catch (error) {\n      return this._appendError(cell, error)\n    }\n  }\n\n  /**\n   * Transpile SQL removing any `output = SELECT ...` extensions and\n   * returning the output names\n   */\n  _transpileSql (sql) {\n    let outputs = []\n    sql = sql.replace(/^(\\s*(\\w+)\\s*=\\s*)\\b(SELECT\\b.+)/img, function (match, group1, group2, group3) {\n      outputs.push({\n        name: group2,\n        expr: group3\n      })\n      // Insert spaces so that error reporting location is correct\n      return ' '.repeat(group1.length) + group3\n    })\n    let output = null\n    if (outputs.length === 1) {\n      output = outputs[0].name\n    } else if (outputs.length > 1) {\n      let names = outputs.map(output => output.name).join(', ')\n      throw new Error(`Cell must have only one output but ${outputs.length} found \"${names}\"`)\n    }\n    return {output, sql}\n  }\n\n  /**\n   * Do string interpolation of variables in SQL code\n   *\n   * @param  {String} sql SQL code with interpolation marks e.g. `SELECT * FROM data WHERE height > ${x} AND width < ${y}`\n   * @return {Object}     Interpolation variable names and interpolated e.g. `{variables:['x', 'y'], sql: 'SELECT * FROM data WHERE height > 10 AND width < 32'}`\n   */\n  _interpolateSql (sql, inputs = {}) {\n    let variables = []\n    sql = sql.replace(/\\${([^{}]*)}/g, function (match, name) {\n      variables.push(name)\n      return inputs[name] || '0'\n    })\n    return {variables, sql}\n  }\n\n  /**\n   * Get table inputs by filtering the AST but exclude those tables that already exist in the database\n   *\n   * @param  {AST}    ast SQL AST\n   * @return {Array}      A list of tables that are inputs into the SQL statement/s\n   */\n  _tableInputs (ast) {\n    let rows = this._db.prepare('SELECT name FROM sqlite_master WHERE type==\"table\"').all()\n    const existing = rows.map(row => row.name)\n\n    const tables = []\n    const search = (object) => {\n      if (object.type === 'identifier' && object.variant === 'table') {\n        if (existing.indexOf(object.name) < 0) tables.push(object.name)\n      } else if (typeof object === 'object') {\n        for (const property of Object.values(object)) {\n          search(property)\n        }\n      }\n    }\n    search(ast.statement[0])\n\n    return tables\n  }\n\n  /**\n   * Unpack an input `{name, value}` object\n   *\n   * @param  {Object} input Input object\n   * @return {Object}       Object with name and unpacked value `{name, value}`\n   */\n  async _unpack (input) {\n    let {name, value: packed} = input\n    if (!packed) return {name} // Input may have not been provided. Deal with better?\n    if (packed.type === 'table') {\n      let table\n      if (packed.data) {\n        table = packed.data\n      } else {\n        table = await this.unpackPointer(packed)\n        if (table.local) {\n          return {name, value: {table: table.table}}\n        }\n      }\n      // Create a table for this input\n      let data = table.data\n      let cols = Object.keys(data)\n      let rows = data[cols[0]].length\n      this._db.exec(`DROP TABLE IF EXISTS inputs.${name}`)\n      this._db.exec(`CREATE TABLE inputs.${name} (${cols.join(', ')})`)\n      let statement = this._db.prepare(`INSERT INTO ${name} VALUES (${Array(cols.length).fill('?').join(',')})`)\n      for (let row = 0; row < rows; row++) {\n        let rowData = []\n        for (let col of cols) rowData.push(data[col][row])\n        statement.run(rowData)\n      }\n      return {name, value: {table: `inputs.${name}`}}\n    } else {\n      return {name, value: await this.unpack(packed)}\n    }\n  }\n\n  async _pack (name, select, node) {\n    if (!name) name = 'tmp' + crypto.randomBytes(12).toString('hex')\n\n    this._db.exec(`DROP TABLE IF EXISTS outputs.${name}`)\n    this._db.exec(`CREATE TABLE outputs.${name} AS ${select}`)\n\n    const MAX_ROWS = 10\n    let pkg = await this.provide({name, limit: MAX_ROWS})\n\n    // Decide to create a package or a data pointer\n    let rowNum = this._db.prepare(`SELECT count(*) FROM outputs.${name}`).pluck().get()\n    if (rowNum <= MAX_ROWS) {\n      return pkg\n    } else {\n      return this.packPointer({type: 'table', name, preview: pkg.data})\n    }\n  }\n\n  /**\n   * Handle an error when compiling or executing a node\n   * including dealing with error locations\n   */\n  _appendError (node, error) {\n    let message = {\n      type: 'error',\n      message: error.message,\n      stack: error.stack\n    }\n    if (error.location) {\n      message.line = error.location.start.line - 1\n      message.column = error.location.start.column - 1\n    }\n    if (!node.messages) node.messages = []\n    node.messages.push(message)\n    return node\n  }\n}\n\nSqliteContext.spec = {\n  name: 'SqliteContext',\n  client: 'ContextHttpClient'\n}\n\nmodule.exports = SqliteContext\n",
    "static": true,
    "longname": "/home/travis/build/stencila/node/lib/contexts/SqliteContext.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 119,
    "kind": "class",
    "name": "SqliteContext",
    "memberof": "lib/contexts/SqliteContext.js",
    "static": true,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext",
    "access": "public",
    "export": true,
    "importPath": "stencila-node/lib/contexts/SqliteContext.js",
    "importStyle": "SqliteContext",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false,
    "extends": [
      "lib/contexts/Context.js~Context"
    ]
  },
  {
    "__docId__": 120,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true
  },
  {
    "__docId__": 121,
    "kind": "member",
    "name": "_db",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#_db",
    "access": "private",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "outputs",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#outputs",
    "access": "public",
    "description": "Get a list of outputs available from this context",
    "lineNumber": 26,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "resolve",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#resolve",
    "access": "public",
    "description": "Resolve an output value",
    "lineNumber": 35,
    "override": true,
    "params": [
      {
        "name": "what",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"local\": boolean, \"table\": *}"
      ]
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "provide",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#provide",
    "access": "public",
    "description": "An override to provide the caller an output value\n(in this context's case, a database table) as a\ndata package",
    "lineNumber": 55,
    "override": true,
    "params": [
      {
        "name": "what",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "compile",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#compile",
    "access": "public",
    "description": "Compile a cell\n\nFor a cell with `expr=true`, checks that the node consists of a single `SELECT` statement. That is, multiple `SELECT` statements,\nor other types of SQL statements, e.g `UPDATE`, `DELETE`, are invalid.\n\nParses SQL to determine the `inputs` property of the node including variable interpolations and tables\ne.g. `SELECT * FROM data WHERE height > ${min_height}` creates the inputs `[\"min_height\", \"data\"]`.\nNote that if a table already exists in the database then it is not included in `inputs` since it does\nnot need to be provided by the execution engine\n\nFor `expr=false` (block) nodes determines if there is an output\ne.g `low_gravity_planets` in `low_gravity_planets = SELECT * FROM planets WHERE gravity <= 1`\n\nChecks for any statements that may cause side effects e.g `DELETE` or `CREATE TABLE` statements",
    "lineNumber": 95,
    "override": true,
    "params": [
      {
        "name": "cell",
        "types": [
          "*"
        ]
      },
      {
        "name": "expr",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": false,
        "defaultValue": "false"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "execute",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#execute",
    "access": "public",
    "description": "Execute a cell",
    "lineNumber": 185,
    "override": true,
    "params": [
      {
        "name": "cell",
        "types": [
          "*"
        ]
      },
      {
        "name": "expr",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": false,
        "defaultValue": "false"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "_transpileSql",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#_transpileSql",
    "access": "private",
    "description": "Transpile SQL removing any `output = SELECT ...` extensions and\nreturning the output names",
    "lineNumber": 257,
    "params": [
      {
        "name": "sql",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"output\": *, \"sql\": *}"
      ]
    }
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "_interpolateSql",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#_interpolateSql",
    "access": "private",
    "description": "Do string interpolation of variables in SQL code",
    "lineNumber": 283,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "sql",
        "description": "SQL code with interpolation marks e.g. `SELECT * FROM data WHERE height > ${x} AND width < ${y}`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Interpolation variable names and interpolated e.g. `{variables:['x', 'y'], sql: 'SELECT * FROM data WHERE height > 10 AND width < 32'}`"
    }
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "_tableInputs",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#_tableInputs",
    "access": "private",
    "description": "Get table inputs by filtering the AST but exclude those tables that already exist in the database",
    "lineNumber": 298,
    "params": [
      {
        "nullable": null,
        "types": [
          "AST"
        ],
        "spread": false,
        "optional": false,
        "name": "ast",
        "description": "SQL AST"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "A list of tables that are inputs into the SQL statement/s"
    }
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "_unpack",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#_unpack",
    "access": "private",
    "description": "Unpack an input `{name, value}` object",
    "lineNumber": 323,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "input",
        "description": "Input object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Object with name and unpacked value `{name, value}`"
    }
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "_pack",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#_pack",
    "access": "private",
    "description": null,
    "lineNumber": 354,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "select",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "_appendError",
    "memberof": "lib/contexts/SqliteContext.js~SqliteContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/contexts/SqliteContext.js~SqliteContext#_appendError",
    "access": "private",
    "description": "Handle an error when compiling or executing a node\nincluding dealing with error locations",
    "lineNumber": 376,
    "params": [
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "error",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "file",
    "name": "lib/host/Host.js",
    "content": "const util = require('util')\n\nconst assert = require('assert')\nconst machine = require('address')\nconst crypto = require('crypto')\nconst execa = require('execa')\nconst fs = require('fs')\nconst glob = util.promisify(require('glob'))\nconst jsonwebtoken = require('jsonwebtoken')\nconst mkdirp = require('mkdirp')\nconst path = require('path')\nconst os = require('os')\nconst request = require('request-promise')\nconst uuid = require('uuid')\n\nconst pkg = require('../../package')\nconst HostHttpServer = require('./HostHttpServer')\n\nconst JupyterContext = require('../contexts/JupyterContext')\nconst NodeContext = require('../contexts/NodeContext')\nconst SqliteContext = require('../contexts/SqliteContext')\n\nconst version = pkg.version\n\n// The current execution environment\n// The `STENCILA_ENVIRON` env var may be set if inside\n// a defined environment e.g. stencila/core@1.2\nconst ENVIRON = process.env.STENCILA_ENVIRON || 'local'\n\n// Types of execution contexts provided by this Host\n// Note that types provided by peers are also available\n// to clients of this host. See `Host.types`\nconst TYPES = {\n  'JupyterContext': JupyterContext,\n  'NodeContext': NodeContext,\n  'SqliteContext': SqliteContext\n}\n\n/**\n * A `Host` allows you to create, get, run methods of, and delete instances of various types.\n * The types can be thought of a \"services\" provided by the host e.g. `NoteContext`\n *\n * The API of a host is similar to that of a HTTP server. It's methods names\n * (e.g. `post`, `get`) are similar to HTTP methods (e.g. `POST`, `GET`) but\n * the sematics sometimes differ (e.g. a host's `put()` method is used to call an\n * instance method)\n *\n * A `Host` is not limited to being served by HTTP and it's methods are exposed by both `HostHttpServer`\n * and `HostWebsocketServer`. Those other classes are responsible for tasks associated with\n * their communication protocol (e.g. serialising and deserialising objects).\n *\n *\n * This is a singleton class. There should only ever be one `Host`\n * in memory in each process (although, for purposes of testing, this is not enforced)\n */\nclass Host {\n  constructor (key = null) {\n    this._id = `node-host-${uuid()}`\n    this._key = key\n    this._servers = {}\n    this._started = null\n    this._heartbeat = null\n    this._instances = {}\n    this._counts = {}\n    this._peers = {}\n  }\n\n  /**\n   * Get unique ID of this host\n   */\n  get id () {\n    return this._id\n  }\n\n  /**\n   * Get the key of this host\n   *\n   * @return {string} - Host's authentication key\n   */\n  get key () {\n    return this._key\n  }\n\n  /**\n   * Get the current user's Stencila data directory\n   */\n  static userDir () {\n    // TODO: isn't there a module helping us to find OS paths?\n    // maybe something which works like electron's app.getPath()\n    // https://github.com/electron/electron/blob/master/docs/api/app.md#appgetpathname\n    switch (process.platform) {\n      // see https://nodejs.org/api/process.html#process_process_platform\n      case 'darwin':\n        return path.join(process.env.HOME, 'Library', 'Application Support', 'Stencila')\n      case 'linux':\n        return path.join(process.env.HOME, '.stencila')\n      case 'win32':\n        return path.join(process.env.APPDATA, 'Stencila')\n      default:\n        return path.join(process.env.HOME, 'stencila')\n    }\n  }\n\n  /**\n   * Is the user running this process a super user?\n   */\n  static isSuperUser () {\n    return (process.getuid && process.getuid() === 0) || process.env.SUDO_UID\n  }\n\n  /**\n   * Get the current Stencila temporary directory\n   */\n  static tempDir () {\n    return path.join(os.tmpdir(), 'stencila')\n  }\n\n  /**\n   * Get the execution environments supported by this host\n   *\n   * @return {Array} A list of supported execution environment\n   */\n  async environs () {\n    let environs = []\n\n    let name = null\n    let version = null\n    const match = ENVIRON.match(/^([\\w-]+)(@(.+)?)$/)\n    if (match) {\n      name = match[1]\n      version = match[3]\n    } else {\n      name = ENVIRON\n    }\n    let current = {\n      id: ENVIRON,\n      name: name,\n      version: version\n    }\n    environs.push(current)\n\n    const pattern = path.join(Host.userDir(), 'environs', '**/*.json')\n    for (let file of glob.sync(pattern)) {\n      const json = fs.readFileSync(file)\n      const environ = JSON.parse(json)\n      environs.push(environ)\n    }\n    return environs\n  }\n\n  /**\n   * Get specifications for context types provided by this\n   * Host, including types provided by peer Hosts.\n   *\n   * Types which are provided by this Host directly are marked\n   * with `local: true`, and those provided by peers with\n   * `local: false`\n   */\n  get types () {\n    let specs = {}\n    for (let [name, type] of Object.entries(TYPES)) {\n      specs[name] = Object.assign(type.spec, {local: true})\n    }\n    for (let peer of Object.values(this._peers)) {\n      const types = peer && peer.manifest && peer.manifest.types\n      if (types) {\n        for (let [name, spec] of Object.entries(types)) {\n          // Only add the type if it is not available locally\n          // on this host\n          if (!specs[name]) {\n            specs[name] = Object.assign(spec, {local: false})\n          }\n        }\n      }\n    }\n    return specs\n  }\n\n  /**\n   * Get information on the machine that this host is running on\n   *\n   * Used for resolving data pointers (amongst other things)\n   *\n   * @return {Object} Machine information\n   */\n  get machine () {\n    return this._machine\n  }\n\n  /**\n   * Get information on the process that this host is running in\n   *\n   * Used by peer hosts to check that this host is runing (amongst other things)\n   *\n   * @return {Object} Process information\n   */\n  get process () {\n    return {\n      pid: process.pid,\n      name: process.title,\n      version: process.version,\n      platform: process.platform,\n      arch: process.arch\n    }\n  }\n\n  /**\n   * Get a manifest for this host\n   *\n   * The manifest describes the host and it's capabilities. It is used\n   * by peer hosts to determine which \"types\" this host provides and\n   * which \"instances\" have already been instantiated.\n   *\n   * @return {Object} Manifest object\n   */\n  async manifest () {\n    let manifest = {\n      stencila: {\n        package: 'node',\n        version: version\n      },\n      id: this.id,\n      spawn: ['stencila-node', 'spawn'],\n      environs: await this.environs(),\n      types: this.types\n    }\n    if (this._started) {\n      manifest = Object.assign(manifest, {\n        machine: this.machine,\n        process: this.process,\n        servers: this.servers,\n        instances: Object.keys(this._instances)\n      })\n    }\n    return manifest\n  }\n\n  /**\n   * Register as a host for the current execution environment.\n   *\n   * Registering a host involves creating a file `node.json` inside of\n   * the current environment's directory within the the user's\n   * Stencila data directory (see `userDir()`).\n   */\n  async register () {\n    const dir = path.join(Host.userDir(), 'hosts')\n    mkdirp.sync(dir)\n    const json = JSON.stringify(await this.manifest(), null, '  ')\n    fs.writeFileSync(path.join(dir, 'node.json'), json)\n  }\n\n  /**\n   * Resolve an instance identifier to an instance\n   *\n   * @param  {String} id Instance identifier\n   * @return {Object}      The instance\n   */\n  resolve (id) {\n    return Promise.resolve().then(() => {\n      let instance = this._instances[id]\n      if (!instance) throw new Error(`No instance with id \"${id}\"`)\n      return instance\n    })\n  }\n\n  async startup (id) {\n    if (id === ENVIRON) {\n      return { path: '' }\n    } else {\n      throw new Error('Creating environments other than local not yet supported')\n    }\n  }\n\n  async shutdown (id) {\n    return true\n  }\n\n  /**\n   * Create a new instance of a type\n   *\n   * @param  {string} type - Type of instance\n   * @param  {options} options - Arguments to be passed to type constructor\n   * @return {Object} - Identier and newly created instance\n   */\n  async create (type, options) {\n    this.heartbeat()\n\n    const makeId = () => {\n      let number = (this._counts[type] || 0) + 1\n      this._counts[type] = number\n      return `${type[0].toLowerCase()}${type.substring(1)}${number}`\n    }\n\n    let id\n    let instance\n\n    let Class = TYPES[type]\n    if (Class) {\n      // Type present locally\n      id = makeId(type)\n      instance = new Class(this, id, options)\n      // Do initialization if class has such a method\n      if (typeof instance.initialize === 'function') await instance.initialize()\n    } else {\n      // Type not present locally, see if a peer has it\n      let peer = await (async () => {\n        // Sort peers so that we search for the type in active, running peers\n        // first and then in registered peers that need to be spawned\n        let peers = Object.values(this._peers).sort((a, b) => {\n          if (a.manifest.process && !b.manifest.process) return -1\n          if (!a.manifest.process && b.manifest.process) return 1\n          return 0\n        })\n        for (let peer of peers) {\n          const types = peer && peer.manifest && peer.manifest.types\n          if (types) {\n            for (let name of Object.keys(types)) {\n              if (name === type) {\n                if (peer.manifest.process) {\n                  // Peer is active, so use it\n                  return peer\n                } else {\n                  // Peer is inactive, so `spawn` it\n                  return this.spawnPeer(peer)\n                }\n              }\n            }\n          }\n        }\n        throw new Error(`No type with name \"${type}\"`)\n      })()\n\n      let remoteId = await this.requestPeer(peer, 'POST', '/' + type, options)\n\n      // Store the instance as a {peer, id pair} to be proxied to. In other methods (e.g. `call`),\n      // such object instances are recognised as remote instances and requests are proxied to them\n      id = makeId(type)\n      instance = {\n        proxy: true,\n        peer,\n        id: remoteId\n      }\n    }\n\n    this._instances[id] = instance\n    return {id, instance}\n  }\n\n  /**\n   * Get an instance\n   *\n   * @param {String} id - Instance identifier\n   */\n  async get (id) {\n    this.heartbeat()\n\n    let instance = await this.resolve(id)\n    if (instance.proxy) {\n      // Pass on request to peer host\n      return this.requestPeer(instance.peer, 'GET', '/' + instance.id)\n    } else {\n      // Return an JSON represenation of the instance\n      // excluding any 'private' propertues\n      if (typeof instance.repr === 'function') {\n        return instance.repr()\n      } else {\n        let repr = {}\n        for (const [key, value] of Object.entries(instance)) {\n          if (key.substring(0, 1) !== '_') repr[key] = value\n        }\n        return repr\n      }\n    }\n  }\n\n  /**\n   * Call a method of an instance\n   *\n   * @param {String} id - Instance identifier\n   * @param {String} method - Name of instance method\n   * @param {Object} data - An object to apply the method to\n   */\n  async call (id, method, data) {\n    this.heartbeat()\n\n    let instance = await this.resolve(id)\n    if (instance.proxy) {\n      // Pass on request to peer host\n      return this.requestPeer(instance.peer, 'PUT', '/' + instance.id + '!' + method, data)\n    } else {\n      let func = instance[method]\n      if (func) {\n        // Call the instance's method\n        return instance[method](data)\n      } else {\n        throw new Error(`Instance \"${id}\" has no method \"${method}\"`)\n      }\n    }\n  }\n\n  /**\n   * Destroy an instance\n   *\n   * @param  {String} id - Instance identifier\n   */\n  async destroy (id) {\n    this.heartbeat()\n\n    let instance = await this.resolve(id)\n    if (instance.proxy) {\n      // Pass on request to peer host\n      return this.requestPeer(instance.peer, 'DELETE', '/' + instance.id)\n    } else {\n      // Do finalization if class has such a method\n      if (typeof instance.finalize === 'function') await instance.finalize()\n      // Delete the instance entry\n      delete this._instances[id]\n    }\n  }\n\n  /**\n   * Start serving this host\n   *\n   * Currently, HTTP is the only server available\n   * for hosts. We plan to implement a `HostWebsocketServer` soon.\n   *\n   * @return {Promise}\n   */\n  async start (options = {}) {\n    let address = options.address || '127.0.0.1'\n    let port = options.port || 2000\n    let key = options.key || null\n    let quiet = options.quiet || false\n\n    if (!this._servers.http) {\n      // Ensure key\n      if (key === null) {\n        if (process.env.STENCILA_AUTH === 'false') key = false\n        else key = crypto.randomBytes(32).toString('hex')\n      }\n      this._key = key\n\n      // Ensure MAC and IP\n      const mac = await (util.promisify(machine.mac))()\n      const ip = machine.ip()\n      this._machine = {\n        id: mac || ip,\n        ip: ip\n      }\n\n      // Start HTTP server\n      var server = new HostHttpServer(this, address, port)\n      this._servers.http = server\n      await server.start()\n\n      if (!quiet) {\n        let key = this._key\n        console.log(`Host has started:\\n  Id: ${this.id}\\n  Key: ${key}\\n  URLs: ${server.url}`) // eslint-disable-line no-console\n        if (key === false) {\n          console.warn(`  Warning: authentication has been disabled!`) // eslint-disable-line no-console\n        }\n      }\n\n      // Record start times\n      this._started = new Date()\n      this._heartbeat = new Date()\n\n      // Register as a running host by creating a manifest file and a key file\n      let hostsDir = path.join(Host.tempDir(), 'hosts')\n      mkdirp.sync(hostsDir)\n      let manifest = await this.manifest()\n      let json = JSON.stringify(manifest, null, '  ')\n      fs.writeFileSync(path.join(hostsDir, this.id + '.json'), json, { mode: '600' })\n      fs.writeFileSync(path.join(hostsDir, this.id + '.key'), this.key, { mode: '600' })\n\n      // Discover other hosts\n      return this.discoverPeers()\n    }\n  }\n\n  /**\n   * Update this host's heartbeat\n   *\n   * Can be called explictly by a peer (i.e. `PUT /!heartbeat`)\n   * but also called by the `post`, `get`, `put` and `delete` methods\n   * above.\n   *\n   * @return {Date} Date/time of last heartbeat\n   */\n  heartbeat () {\n    this._heartbeat = new Date()\n    return this._heartbeat\n  }\n\n  /**\n   * Stop serving this host\n   *\n   * @return {Promise}\n   */\n  stop (options = {}) {\n    let quiet = options.quiet || false\n\n    return new Promise((resolve) => {\n      const type = 'http'\n      let server = this._servers[type]\n      if (server) {\n        delete this._servers[type]\n        server.stop().then(() => {\n          // Deregister as a running host by removing manifest and key files\n          let hostsDir = path.join(Host.tempDir(), 'hosts')\n          let manifestFile = path.join(hostsDir, this.id + '.json')\n          fs.unlink(manifestFile, () => {})\n          let keyFile = path.join(hostsDir, this.id + '.key')\n          fs.unlink(keyFile, () => {})\n\n          // Stop any child peers that this host spawned\n          for (let peer of Object.values(this._peers)) {\n            if (peer.child) {\n              console.log(`Stopping peer host \"${peer.id}\".`)\n              // Use both SIGINT and SIGTERM (which is not handled on Windows)\n              peer.child.kill('SIGINT')\n              peer.child.kill('SIGTERM')\n            }\n          }\n\n          // Destroy all instances created to trigger any finalization they may do\n          for (let id of Object.keys(this._instances)) {\n            this.destroy(id)\n          }\n\n          if (!quiet) console.log('Host HTTP server has stopped.') // eslint-disable-line no-console\n\n          resolve()\n        })\n      }\n    })\n  }\n\n  /**\n   * Start serving this host and wait for connections\n   * indefinitely\n   */\n  run (options = {}) {\n    let address = options.address || '127.0.0.1'\n    let port = options.port || 2000\n    let key = options.key || null\n    let timeout = options.timeout || Infinity\n    let duration = options.duration || Infinity\n    let quiet = options.quiet || false\n\n    const stop = () => {\n      this.stop({quiet: quiet}).then(() => {\n        process.exit()\n      })\n    }\n\n    // Setup timer to check timeout and duration every minute\n    setInterval(() => {\n      const time = new Date()\n      if ((time - this._heartbeat) / 1000 > timeout || (time - this._started) / 1000 >= duration) {\n        stop()\n      }\n    }, 60 * 1000)\n\n    // Handle interrupt\n    if (process.platform === 'win32') {\n      var rl = require('readline').createInterface({\n        input: process.stdin,\n        output: process.stdout\n      })\n      rl.on('SIGINT', () => process.emit('SIGINT'))\n    }\n    process.on('SIGINT', stop)\n\n    return this.start({address, port, key, quiet})\n  }\n\n  async spawn (options = {}) {\n    options.quiet = true\n    await this.run(options)\n    return {\n      id: this.id,\n      manifest: this.manifest,\n      key: this.key\n    }\n  }\n\n  /**\n   * Get a list of server names for this host\n   *\n   * Servers are identified by the protocol shorthand\n   * e.g. `http` for `HostHttpServer`\n   *\n   * @return {array} Array of strings\n   */\n  get servers () {\n    let servers = {}\n    for (let name of Object.keys(this._servers)) {\n      let server = this._servers[name]\n      servers[name] = {\n        url: server.url,\n        address: server.address,\n        port: server.port\n      }\n    }\n    return servers\n  }\n\n  /**\n   * Get a list of URLs for this host\n   *\n   * @return {array} Array of strings\n   */\n  get urls () {\n    return Object.keys(this._servers).map(name => this._servers[name].url)\n  }\n\n  /**\n   * View this host in the browser\n   *\n   * Opens the default browser at the URL of this host\n   */\n  view () {\n    // Difficult to test headlessly, so don't include in coverage\n    /* istanbul ignore next */\n    Promise.resolve(\n      this.start()\n        .then(() => {\n          let url = this._servers.http.url\n          if (os.platform() === 'linux') {\n            execa(`2>/dev/null 1>&2 xdg-open \"${url}\"`)\n          } else {\n            execa(`open \"${url}\"`)\n          }\n        })\n    )\n  }\n\n  registerPeer ({id, manifest, key}, child) {\n    assert(id)\n    assert(id !== this.id)\n\n    let peer = {\n      id,\n      manifest: manifest || {},\n      key,\n      child,\n      tokens: {} // TODO: garbage collection of expired tokens to reduce memory usage\n    }\n    this._peers[id] = peer\n    return peer\n  }\n\n  /**\n   * Discover peers\n   *\n   * Looks for peer hosts in the following locations (on Linux, equivalents on other OSs):\n   *\n   * - `/tmp/stencila/hosts` - hosts that are currently active (i.e. running)\n   * - `~/.stencila/hosts` - hosts that are installed but inactive\n   *\n   * This method is intended to be robust to errors in peer files etc and\n   * will only register an active peer if it can connect to it and access its\n   * key file\n   */\n  async discoverPeers () {\n    let discoverDir = async dir => {\n      // Check the folder exists (they may not e.g. if no packages have been registered)\n      try {\n        await fs.accessSync(dir, fs.constants.R_OK)\n      } catch (error) {\n        return\n      }\n      // For each host in the directory\n      for (let file of await glob(path.join(dir, '*.json'))) {\n        let json\n        try {\n          json = fs.readFileSync(file, { encoding: 'utf8' })\n        } catch (error) {\n          console.warn(`Warning: error reading file \"${file}\": ${error.message}`)\n          continue\n        }\n\n        let manifest\n        try {\n          manifest = JSON.parse(json)\n        } catch (error) {\n          console.warn(`Warning: error parsing file \"${file}\": ${error.message}`)\n          continue\n        }\n        const id = manifest.id\n\n        // Don't register no id or self as a peer!\n        if (!id || id === this.id) continue\n\n        // If the manifest defines a `process` then check that process is actually running\n        const pid = manifest.process && manifest.process.pid\n        if (pid) {\n          try {\n            process.kill(pid, 0)\n          } catch (error) {\n            if (error.code === 'ESRCH') {\n              console.warn(`Warning: no active peer process with pid \"${pid}\"`)\n            } else {\n              console.warn(`Warning: error checking process with pid \"${pid}\": ${error.message}`)\n            }\n            continue\n          }\n        }\n\n        // If the manifest defines `servers` then check that we are able to connect to\n        // it and update the manifest\n        if (manifest.servers && manifest.servers.http) {\n          try {\n            manifest = await this.requestPeer(manifest.servers.http.url + '/manifest')\n          } catch (error) {\n            console.warn(`Warning: error attempting to connect to peer: ${error.message}`)\n            continue\n          }\n        }\n\n        // If the manifest defines `servers` then obtain its key so that requests can\n        // be made to it.\n        let key\n        if (manifest.servers && Object.keys(manifest.servers).length) {\n          const keyFile = path.join(dir, id + '.key')\n          try {\n            key = fs.readFileSync(keyFile, { encoding: 'utf8' })\n          } catch (error) {\n            console.warn(`Warning: error reading file \"${keyFile}\": ${error.message}`)\n            continue\n          }\n        }\n\n        // If we got here, then it's OK to use this as a peer\n        this.registerPeer({id, manifest, key})\n      }\n    }\n    // Discover active hosts first,...\n    await discoverDir(path.join(Host.tempDir(), 'hosts'))\n    // ...then inactive hosts\n    await discoverDir(path.join(Host.userDir(), 'hosts'))\n    // ...then Jupyter kernels installed locally\n    await JupyterContext.discover()\n  }\n\n  /**\n   * Spawn a peer from an inactive host manifest\n   *\n   * @param  {Object} peer A peer object including `manifest`\n   * @return {[type]}      [description]\n   */\n  spawnPeer (peer) {\n    return new Promise((resolve, reject) => {\n      let spawn = peer.manifest.spawn\n      let child = execa(spawn[0], spawn.slice(1))\n      child.stdout.on('data', data => {\n        const spawnedPeer = JSON.parse(data.toString())\n        this.registerPeer(spawnedPeer, child)\n        resolve(spawnedPeer)\n      })\n      child.catch(error => {\n        reject(new Error(`Could not spawn peer using \"${spawn.join(' ')}\": ${error.message}`))\n      })\n    })\n  }\n\n  async requestPeer (peer, method = 'GET', path = '', data = null) {\n    let url\n    let headers = {\n      Accept: 'application/json'\n    }\n    if (typeof peer === 'string') {\n      url = peer\n    } else {\n      url = peer.manifest.servers['http'].url\n      headers['Authorization'] = 'Bearer ' + await this.generateToken(peer.id)\n    }\n    return request({\n      method: method,\n      uri: url + path,\n      headers: headers,\n      jar: true,\n      body: data,\n      json: true\n    })\n  }\n\n  /**\n   * Generate a request token\n   *\n   * @param {String} host The id of the host\n   */\n  async generateToken (host) {\n    let peer = this._peers[host]\n    if (!peer) throw new Error(`Could not find peer with id \"${host}\"`)\n\n    // If the peer has no key then auth is turned off\n    // and so token is an empty string\n    if (!peer.key) return ''\n\n    return jsonwebtoken.sign({\n      // `iat` and `exp` claims are added by `jsonwebtoken`\n      iss: this.id,\n      jti: crypto.randomBytes(32).toString('hex')\n    }, peer.key, {\n      algorithm: 'HS256',\n      expiresIn: 300\n    })\n  }\n\n  /**\n   * Authorize a request token.\n   *\n   * Throws an error if the token is invalid.\n   *\n   * @param {String} token Token string (usually from the `Authorization` header of a HTTP request)\n   */\n  authorizeToken (token) {\n    // If key is explicitly set to false then no authorization is done\n    if (this._key === false) return true\n\n    // Note that `jsonwebtoken.verify` will return the\n    // \"decoded payload if the signature is valid and optional expiration, audience, or issuer are valid\"\n    let payload = jsonwebtoken.verify(token, this.key, {\n      algorithms: ['HS256']\n    })\n\n    // Verify `iss` and `jti`\n    // These can, optionally, be set by clients to prevent token replay attacks.\n    const iss = payload.iss // Issuer\n    const jti = payload.jti // JWT ID\n    if (iss && jti) {\n      let peer = this._peers[iss]\n      if (!peer) {\n        // Request is from a host that is not yet registered\n        peer = this.registerPeer({id: iss})\n      }\n      if (peer.tokens.hasOwnProperty(jti)) throw new Error(`Attempt to reuse a token with 'iss': \"${iss}\" and 'jti': \"${jti}\"`)\n      peer.tokens[jti] = payload\n    }\n    return payload\n  }\n\n  /**\n   * Compile a library\n   *\n   * @param  {Object} options Options for the `NodeContext.compileLibrary` method\n   * @return {Object}     Library node including `bundle`, the path to the bundle created\n   */\n  async compile (options) {\n    const context = new NodeContext()\n    return context.compileLibrary(options)\n  }\n}\n\nmodule.exports = Host\n",
    "static": true,
    "longname": "/home/travis/build/stencila/node/lib/host/Host.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 134,
    "kind": "variable",
    "name": "glob",
    "memberof": "lib/host/Host.js",
    "static": true,
    "longname": "lib/host/Host.js~glob",
    "access": "public",
    "export": false,
    "importPath": "stencila-node/lib/host/Host.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 135,
    "kind": "variable",
    "name": "version",
    "memberof": "lib/host/Host.js",
    "static": true,
    "longname": "lib/host/Host.js~version",
    "access": "public",
    "export": false,
    "importPath": "stencila-node/lib/host/Host.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 136,
    "kind": "variable",
    "name": "ENVIRON",
    "memberof": "lib/host/Host.js",
    "static": true,
    "longname": "lib/host/Host.js~ENVIRON",
    "access": "public",
    "export": false,
    "importPath": "stencila-node/lib/host/Host.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 137,
    "kind": "variable",
    "name": "TYPES",
    "memberof": "lib/host/Host.js",
    "static": true,
    "longname": "lib/host/Host.js~TYPES",
    "access": "public",
    "export": false,
    "importPath": "stencila-node/lib/host/Host.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "{\"JupyterContext\": *, \"NodeContext\": *, \"SqliteContext\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 138,
    "kind": "class",
    "name": "Host",
    "memberof": "lib/host/Host.js",
    "static": true,
    "longname": "lib/host/Host.js~Host",
    "access": "public",
    "export": true,
    "importPath": "stencila-node/lib/host/Host.js",
    "importStyle": "Host",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 139,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "_id",
    "memberof": "lib/host/Host.js~Host",
    "static": false,
    "longname": "lib/host/Host.js~Host#_id",
    "access": "private",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "_key",
    "memberof": "lib/host/Host.js~Host",
    "static": false,
    "longname": "lib/host/Host.js~Host#_key",
    "access": "private",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "_servers",
    "memberof": "lib/host/Host.js~Host",
    "static": false,
    "longname": "lib/host/Host.js~Host#_servers",
    "access": "private",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "_started",
    "memberof": "lib/host/Host.js~Host",
    "static": false,
    "longname": "lib/host/Host.js~Host#_started",
    "access": "private",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "member",
    "name": "_heartbeat",
    "memberof": "lib/host/Host.js~Host",
    "static": false,
    "longname": "lib/host/Host.js~Host#_heartbeat",
    "access": "private",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "member",
    "name": "_instances",
    "memberof": "lib/host/Host.js~Host",
    "static": false,
    "longname": "lib/host/Host.js~Host#_instances",
    "access": "private",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "member",
    "name": "_counts",
    "memberof": "lib/host/Host.js~Host",
    "static": false,
    "longname": "lib/host/Host.js~Host#_counts",
    "access": "private",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "member",
    "name": "_peers",
    "memberof": "lib/host/Host.js~Host",
    "static": false,
    "longname": "lib/host/Host.js~Host#_peers",
    "access": "private",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "get",
    "name": "id",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#id",
    "access": "public",
    "description": "Get unique ID of this host",
    "lineNumber": 71,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "get",
    "name": "key",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#key",
    "access": "public",
    "description": "Get the key of this host",
    "lineNumber": 80,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Host's authentication key"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "userDir",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/host/Host.js~Host.userDir",
    "access": "public",
    "description": "Get the current user's Stencila data directory",
    "lineNumber": 87,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "isSuperUser",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/host/Host.js~Host.isSuperUser",
    "access": "public",
    "description": "Is the user running this process a super user?",
    "lineNumber": 107,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "tempDir",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/host/Host.js~Host.tempDir",
    "access": "public",
    "description": "Get the current Stencila temporary directory",
    "lineNumber": 114,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "environs",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#environs",
    "access": "public",
    "description": "Get the execution environments supported by this host",
    "lineNumber": 123,
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "A list of supported execution environment"
    },
    "params": []
  },
  {
    "__docId__": 154,
    "kind": "get",
    "name": "types",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#types",
    "access": "public",
    "description": "Get specifications for context types provided by this\nHost, including types provided by peer Hosts.\n\nTypes which are provided by this Host directly are marked\nwith `local: true`, and those provided by peers with\n`local: false`",
    "lineNumber": 159,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "get",
    "name": "machine",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#machine",
    "access": "public",
    "description": "Get information on the machine that this host is running on\n\nUsed for resolving data pointers (amongst other things)",
    "lineNumber": 186,
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Machine information"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "get",
    "name": "process",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#process",
    "access": "public",
    "description": "Get information on the process that this host is running in\n\nUsed by peer hosts to check that this host is runing (amongst other things)",
    "lineNumber": 197,
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Process information"
    },
    "type": {
      "types": [
        "{\"pid\": *, \"name\": *, \"version\": *, \"platform\": *, \"arch\": *}"
      ]
    }
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "manifest",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#manifest",
    "access": "public",
    "description": "Get a manifest for this host\n\nThe manifest describes the host and it's capabilities. It is used\nby peer hosts to determine which \"types\" this host provides and\nwhich \"instances\" have already been instantiated.",
    "lineNumber": 216,
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Manifest object"
    },
    "params": []
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "register",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#register",
    "access": "public",
    "description": "Register as a host for the current execution environment.\n\nRegistering a host involves creating a file `node.json` inside of\nthe current environment's directory within the the user's\nStencila data directory (see `userDir()`).",
    "lineNumber": 245,
    "params": [],
    "return": null
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "resolve",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#resolve",
    "access": "public",
    "description": "Resolve an instance identifier to an instance",
    "lineNumber": 258,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Instance identifier"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "The instance"
    }
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "startup",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#startup",
    "access": "public",
    "description": null,
    "lineNumber": 266,
    "undocument": true,
    "params": [
      {
        "name": "id",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"path\": *}"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "shutdown",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#shutdown",
    "access": "public",
    "description": null,
    "lineNumber": 274,
    "undocument": true,
    "params": [
      {
        "name": "id",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "create",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#create",
    "access": "public",
    "description": "Create a new instance of a type",
    "lineNumber": 285,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "Type of instance"
      },
      {
        "nullable": null,
        "types": [
          "options"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Arguments to be passed to type constructor"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Identier and newly created instance"
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "get",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#get",
    "access": "public",
    "description": "Get an instance",
    "lineNumber": 354,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Instance identifier"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "call",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#call",
    "access": "public",
    "description": "Call a method of an instance",
    "lineNumber": 383,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Instance identifier"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "Name of instance method"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "An object to apply the method to"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "destroy",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#destroy",
    "access": "public",
    "description": "Destroy an instance",
    "lineNumber": 406,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Instance identifier"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "start",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#start",
    "access": "public",
    "description": "Start serving this host\n\nCurrently, HTTP is the only server available\nfor hosts. We plan to implement a `HostWebsocketServer` soon.",
    "lineNumber": 429,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": [
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ]
  },
  {
    "__docId__": 168,
    "kind": "member",
    "name": "_machine",
    "memberof": "lib/host/Host.js~Host",
    "static": false,
    "longname": "lib/host/Host.js~Host#_machine",
    "access": "private",
    "description": null,
    "lineNumber": 446,
    "undocument": true,
    "type": {
      "types": [
        "{\"id\": *, \"ip\": *}"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "method",
    "name": "heartbeat",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#heartbeat",
    "access": "public",
    "description": "Update this host's heartbeat\n\nCan be called explictly by a peer (i.e. `PUT /!heartbeat`)\nbut also called by the `post`, `get`, `put` and `delete` methods\nabove.",
    "lineNumber": 490,
    "return": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": "Date/time of last heartbeat"
    },
    "params": []
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "stop",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#stop",
    "access": "public",
    "description": "Stop serving this host",
    "lineNumber": 500,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": [
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ]
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "run",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#run",
    "access": "public",
    "description": "Start serving this host and wait for connections\nindefinitely",
    "lineNumber": 543,
    "params": [
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "spawn",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#spawn",
    "access": "public",
    "description": null,
    "lineNumber": 578,
    "undocument": true,
    "params": [
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "{\"id\": *, \"manifest\": *, \"key\": *}"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "get",
    "name": "servers",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#servers",
    "access": "public",
    "description": "Get a list of server names for this host\n\nServers are identified by the protocol shorthand\ne.g. `http` for `HostHttpServer`",
    "lineNumber": 596,
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "Array of strings"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "get",
    "name": "urls",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#urls",
    "access": "public",
    "description": "Get a list of URLs for this host",
    "lineNumber": 614,
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "Array of strings"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "method",
    "name": "view",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#view",
    "access": "public",
    "description": "View this host in the browser\n\nOpens the default browser at the URL of this host",
    "lineNumber": 623,
    "params": [],
    "return": null
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "registerPeer",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#registerPeer",
    "access": "public",
    "description": null,
    "lineNumber": 639,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"id\": *, \"manifest\": *, \"key\": *}"
        ],
        "defaultRaw": {
          "id": null,
          "manifest": null,
          "key": null
        },
        "defaultValue": "{\"id\":null,\"manifest\":null,\"key\":null}"
      },
      {
        "name": "child",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "discoverPeers",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#discoverPeers",
    "access": "public",
    "description": "Discover peers\n\nLooks for peer hosts in the following locations (on Linux, equivalents on other OSs):\n\n- `/tmp/stencila/hosts` - hosts that are currently active (i.e. running)\n- `~/.stencila/hosts` - hosts that are installed but inactive\n\nThis method is intended to be robust to errors in peer files etc and\nwill only register an active peer if it can connect to it and access its\nkey file",
    "lineNumber": 666,
    "params": [],
    "return": null
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "spawnPeer",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#spawnPeer",
    "access": "public",
    "description": "Spawn a peer from an inactive host manifest",
    "lineNumber": 753,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "peer",
        "description": "A peer object including `manifest`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "[type]"
      ],
      "spread": false,
      "description": "[description]"
    }
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "requestPeer",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#requestPeer",
    "access": "public",
    "description": null,
    "lineNumber": 768,
    "undocument": true,
    "params": [
      {
        "name": "peer",
        "types": [
          "*"
        ]
      },
      {
        "name": "method",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "GET",
        "defaultValue": "GET"
      },
      {
        "name": "path",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "",
        "defaultValue": ""
      },
      {
        "name": "data",
        "optional": true,
        "types": [
          "undefined"
        ],
        "defaultValue": "undefined"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "generateToken",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#generateToken",
    "access": "public",
    "description": "Generate a request token",
    "lineNumber": 794,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "host",
        "description": "The id of the host"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "method",
    "name": "authorizeToken",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/Host.js~Host#authorizeToken",
    "access": "public",
    "description": "Authorize a request token.\n\nThrows an error if the token is invalid.",
    "lineNumber": 819,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "token",
        "description": "Token string (usually from the `Authorization` header of a HTTP request)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "method",
    "name": "compile",
    "memberof": "lib/host/Host.js~Host",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/host/Host.js~Host#compile",
    "access": "public",
    "description": "Compile a library",
    "lineNumber": 851,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Options for the `NodeContext.compileLibrary` method"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Library node including `bundle`, the path to the bundle created"
    }
  },
  {
    "__docId__": 186,
    "kind": "file",
    "name": "lib/host/HostHttpServer.js",
    "content": "const assert = require('assert')\nconst body = require('body')\nconst http = require('http')\nconst path = require('path')\nconst send = require('send')\nconst url = require('url')\n\nconst pathIsInside = require('path-is-inside')\nconst httpShutdown = require('http-shutdown')\n\n/**\n * A HTTP server for a `Host`\n */\nclass HostHttpServer {\n  constructor (host, address = '127.0.0.1', port = 2000) {\n    assert(host && host.constructor.name === 'Host', 'host must be an instance of Host')\n\n    this._host = host\n    this._address = address\n    this._port = port\n    this._server = null\n  }\n\n  get address () {\n    return this._address\n  }\n\n  get port () {\n    return this._port\n  }\n\n  /**\n   * Get the URL of this server\n   *\n   * @return {string} - Server's URL, `null` if not serving\n   */\n  get url () {\n    return this._server ? ('http://' + this._address + ':' + this._port) : null\n  }\n\n  /**\n   * Start this server\n   *\n   * @return {Promise}\n   */\n  start () {\n    return new Promise((resolve, reject) => {\n      if (!this._server) {\n        if (require('../host/Host').isSuperUser()) {\n          return reject(new Error('Serving host as a super user is dangerous and is not allowed'))\n        }\n\n        let server = http.createServer(this.handle.bind(this))\n        server = httpShutdown(server)\n        server.on('error', error => {\n          if (error.code === 'EADDRINUSE') {\n            this._port += 10\n            server.close()\n            server.listen(this._port, this._address, 511)\n          } else {\n            reject(error)\n          }\n        })\n        server.on('listening', () => {\n          resolve()\n        })\n        server.listen(this._port, this._address, 511)\n        this._server = server\n      } else {\n        resolve()\n      }\n    })\n  }\n\n  /**\n   * Stop this server\n   *\n   * @return {Promise}\n   */\n  stop () {\n    return new Promise((resolve) => {\n      if (this._server) {\n        this._server.shutdown()\n        this._server = null\n      }\n      resolve()\n    })\n  }\n\n  /**\n   * Handle a HTTP request\n   */\n  handle (request, response) {\n    let uri = url.parse(request.url, true)\n\n    // Check authorization\n    let authorized = false\n    if (!this._host.key) {\n      authorized = true\n    } else {\n      const authHeader = request.headers.authorization\n      if (authHeader) {\n        const match = authHeader.match(/^Bearer (.+)/)\n        if (match) {\n          let token = match[1]\n          try {\n            this._host.authorizeToken(token)\n            authorized = true\n          } catch (error) {\n            return this.error403(request, response, error.message)\n          }\n        }\n      }\n    }\n\n    // Add CORS headers used to control access by browsers. In particular, CORS\n    // can prevent access by XHR requests made by Javascript in third party sites.\n    // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\n\n    // Get the Origin header (sent in CORS and POST requests) and fall back to Referer header\n    // if it is not present (either of these should be present in most browser requests)\n    let origin = request.headers.origin\n    if (!origin && request.headers.referer) {\n      let uri = url.parse(request.headers.referer || '')\n      origin = `${uri.protocol}//${uri.host}`\n    }\n\n    // Check that origin is in whitelist of file://, http://127.0.0.1, http://localhost, or http://*.stenci.la\n    // The origin 'file://' is sent when a connection is made from Electron (i.e Stencila Desktop)\n    if (origin) {\n      if (origin !== 'file://') {\n        let host = url.parse(origin).hostname\n        let match = host.match(/^((127\\.0\\.0\\.1)|(localhost)|(([^.]+\\.)?stenci\\.la))$/)\n        if (!match) origin = null\n      }\n    }\n\n    // If an origin has been found and is authorized set CORS headers\n    // Without these headers browser XHR request get an error like:\n    //     No 'Access-Control-Allow-Origin' header is present on the requested resource.\n    //     Origin 'http://evil.hackers:4000' is therefore not allowed access.\n    if (origin) {\n      // 'Simple' requests (GET and POST XHR requests)\n      response.setHeader('Access-Control-Allow-Origin', origin)\n      // Allow sending cookies and other credentials\n      response.setHeader('Access-Control-Allow-Credentials', 'true')\n      // Pre-flighted requests by OPTIONS method (made before PUT, DELETE etc XHR requests and in other circumstances)\n      // get additional CORS headers\n      if (request.method === 'OPTIONS') {\n        // Allowable methods and headers\n        response.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')\n        // According to MDN \"The simple headers, Accept, Accept-Language, Content-Language, Content-Type are always available and\n        // don't need to be listed by this header.\" but I found it was necessary\n        response.setHeader('Access-Control-Allow-Headers', 'Authorization, Content-Type')\n        // \"how long the response to the preflight request can be cached for without sending another preflight request\"\n        response.setHeader('Access-Control-Max-Age', '86400') // 24 hours\n      }\n    }\n\n    if (request.method === 'OPTIONS') {\n      // For preflighted CORS OPTIONS requests return an empty response with headers set\n      // (https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests)\n      response.end()\n    } else {\n      let endpoint = this.route(request.method, uri.pathname, authorized)\n      if (endpoint) {\n        return new Promise((resolve, reject) => {\n          // Handle mock requests used during testing\n          if (request._setBody) resolve(JSON.stringify(request.body))\n          else {\n            body(request, (err, body) => {\n              if (err) reject(err)\n              else resolve(body)\n            })\n          }\n        }).then(body => {\n          let method = endpoint[0]\n          let params = endpoint.slice(1)\n          let data = body ? JSON.parse(body) : {}\n          return method.call(this, request, response, ...params, data)\n        }).catch(error => {\n          this.error500(request, response, error)\n        })\n      } else {\n        return this.error400(request, response)\n      }\n    }\n  }\n\n  /**\n   * Route a HTTP request\n   *\n   * @param {string} verb - The request's HTTP verb (aka. \"method\") eg. GET\n   * @param {string} path - The requested path\n   * @param {Boolean} authorized - Is the request authorized\n   * @return {array} - An array with first element being the method to call,\n   *                   and subsequent elements being the call arguments\n   */\n  route (verb, path, authorized) {\n    // Public endpoints\n\n    if (path === '/') return [this.home]\n    if (path.substring(0, 8) === '/static/') return [this.statico, path.substring(8)]\n    if (path === '/manifest') return [this.manifest]\n\n    // Private endpoints for which authorization is necessary\n\n    if (!authorized) return [this.error403, `Authorization is required for ${verb} ${path}`]\n\n    let matches = path.match(/^\\/([^!$]+)((!|\\$)([^?]+))?.*$/)\n    if (matches) {\n      let id = matches[1]\n      let operator = matches[3]\n      let method = matches[4]\n      if (verb === 'POST' && id && !method) {\n        if (id.substring(0, 8) === 'environ/') return [this.startup, id.substring(8)]\n        else return [this.create, id]\n      } else if (verb === 'GET' && id && !method) {\n        return [this.get, id]\n      } else if (verb === 'PUT' && id && operator === '!' && method) {\n        return [this.call, id, method]\n      } else if (verb === 'DELETE' && id && !method) {\n        if (id.substring(0, 8) === 'environ/') return [this.shutdown, id.substring(8)]\n        else return [this.destroy, id]\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Handle a request to `home`\n   */\n  home (request, response) {\n    return this.statico(request, response, 'index.html')\n  }\n\n  /**\n   * Handle a request for a static file\n   */\n  statico (request, response, path_) {\n    return new Promise((resolve) => {\n      let staticPath = path.join(__dirname, '../../static')\n      let requestedPath = path.join(staticPath, url.parse(path_).pathname)\n      if (!pathIsInside(requestedPath, staticPath)) {\n        this.error403(request, response, path_)\n        resolve()\n      } else {\n        send(request, requestedPath)\n          .on('error', (err) => {\n            if (err.status === 404) this.error404(request, response, path_)\n            else this.error500(request, response, path_)\n            resolve()\n          })\n          .on('end', resolve)\n          .pipe(response)\n      }\n    })\n  }\n\n  /**\n   * Handle a request to `manifest`\n   */\n  manifest (request, response) {\n    this._host.manifest().then(manifest => {\n      response.setHeader('Content-Type', 'application/json')\n      response.end(JSON.stringify(manifest))\n    })\n  }\n\n  /**\n   * Handle a request to startup an environment\n   */\n  startup (request, response, type, options) {\n    return this._host.startup(type, options).then(result => {\n      response.setHeader('Content-Type', 'application/json')\n      response.end(JSON.stringify(result))\n    })\n  }\n\n  /**\n   * Handle a request to shutdown an environment\n   */\n  shutdown (request, response, type, options) {\n    return this._host.shutdown(type, options).then(result => {\n      response.setHeader('Content-Type', 'application/json')\n      response.end(JSON.stringify(result))\n    })\n  }\n\n  /**\n   * Handle a request to create an instance\n   */\n  create (request, response, type, options) {\n    return this._host.create(type, options).then(result => {\n      response.setHeader('Content-Type', 'application/json')\n      response.end(JSON.stringify(result.id))\n    })\n  }\n\n  /**\n   * Handle a request to get an instance\n   */\n  get (request, response, name) {\n    return this._host.get(name).then(repr => {\n      response.setHeader('Content-Type', 'application/json')\n      response.end(JSON.stringify(repr))\n    })\n  }\n\n  /**\n   * Handle a request to call an instance method\n   */\n  call (request, response, name, method, data) {\n    return this._host.call(name, method, data).then(result => {\n      response.setHeader('Content-Type', 'application/json')\n      response.end(JSON.stringify(result))\n    })\n  }\n\n  /**\n   * Handle a request to destroy an instance\n   */\n  destroy (request, response, name) {\n    return this._host.destroy(name).then(() => {\n      response.end()\n    })\n  }\n\n  /**\n   * General error handling\n   */\n  error (request, response, status, error) {\n    return new Promise((resolve) => {\n      response.statusCode = status\n      let content\n      if (acceptsJson(request)) {\n        response.setHeader('Content-Type', 'application/json')\n        content = JSON.stringify(error)\n      } else {\n        content = error.error + ': ' + error.details\n      }\n      response.end(content)\n      resolve()\n    })\n  }\n\n  /**\n   * Specific error handling functions\n   */\n\n  error400 (request, response, details) {\n    details = details || (request.method + ' ' + request.url)\n    return this.error(request, response, 400, {error: 'Bad request', details: details})\n  }\n\n  error403 (request, response, details) {\n    return this.error(request, response, 403, {error: 'Forbidden', details: details})\n  }\n\n  error404 (request, response, details) {\n    return this.error(request, response, 404, {error: 'Not found', details: details})\n  }\n\n  error500 (request, response, error) {\n    /* istanbul ignore next */\n    return this.error(request, response, 500, {error: 'Internal error', details: error ? error.stack : ''})\n  }\n}\n\nfunction acceptsJson (request) {\n  let accept = request.headers['accept'] || ''\n  return accept.match(/application\\/json/)\n}\n\nmodule.exports = HostHttpServer\n",
    "static": true,
    "longname": "/home/travis/build/stencila/node/lib/host/HostHttpServer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 187,
    "kind": "function",
    "name": "acceptsJson",
    "memberof": "lib/host/HostHttpServer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/host/HostHttpServer.js~acceptsJson",
    "access": "public",
    "export": false,
    "importPath": "stencila-node/lib/host/HostHttpServer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 371,
    "undocument": true,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 188,
    "kind": "class",
    "name": "HostHttpServer",
    "memberof": "lib/host/HostHttpServer.js",
    "static": true,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer",
    "access": "public",
    "export": true,
    "importPath": "stencila-node/lib/host/HostHttpServer.js",
    "importStyle": "HostHttpServer",
    "description": "A HTTP server for a `Host`",
    "lineNumber": 14,
    "interface": false
  },
  {
    "__docId__": 189,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true
  },
  {
    "__docId__": 190,
    "kind": "member",
    "name": "_host",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#_host",
    "access": "private",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 191,
    "kind": "member",
    "name": "_address",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#_address",
    "access": "private",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "member",
    "name": "_port",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#_port",
    "access": "private",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "member",
    "name": "_server",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#_server",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "get",
    "name": "address",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#address",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "get",
    "name": "port",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#port",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "get",
    "name": "url",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#url",
    "access": "public",
    "description": "Get the URL of this server",
    "lineNumber": 37,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Server's URL, `null` if not serving"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "method",
    "name": "start",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#start",
    "access": "public",
    "description": "Start this server",
    "lineNumber": 46,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 200,
    "kind": "method",
    "name": "stop",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#stop",
    "access": "public",
    "description": "Stop this server",
    "lineNumber": 80,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "handle",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#handle",
    "access": "public",
    "description": "Handle a HTTP request",
    "lineNumber": 93,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 203,
    "kind": "method",
    "name": "route",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#route",
    "access": "public",
    "description": "Route a HTTP request",
    "lineNumber": 199,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verb",
        "description": "The request's HTTP verb (aka. \"method\") eg. GET"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "The requested path"
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "authorized",
        "description": "Is the request authorized"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "An array with first element being the method to call,\n                  and subsequent elements being the call arguments"
    }
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "home",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#home",
    "access": "public",
    "description": "Handle a request to `home`",
    "lineNumber": 234,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "statico",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#statico",
    "access": "public",
    "description": "Handle a request for a static file",
    "lineNumber": 241,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "path_",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "manifest",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#manifest",
    "access": "public",
    "description": "Handle a request to `manifest`",
    "lineNumber": 264,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "startup",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#startup",
    "access": "public",
    "description": "Handle a request to startup an environment",
    "lineNumber": 274,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "shutdown",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#shutdown",
    "access": "public",
    "description": "Handle a request to shutdown an environment",
    "lineNumber": 284,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 209,
    "kind": "method",
    "name": "create",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#create",
    "access": "public",
    "description": "Handle a request to create an instance",
    "lineNumber": 294,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "method",
    "name": "get",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#get",
    "access": "public",
    "description": "Handle a request to get an instance",
    "lineNumber": 304,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "call",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#call",
    "access": "public",
    "description": "Handle a request to call an instance method",
    "lineNumber": 314,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "method",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "destroy",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#destroy",
    "access": "public",
    "description": "Handle a request to destroy an instance",
    "lineNumber": 324,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "error",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#error",
    "access": "public",
    "description": "General error handling",
    "lineNumber": 333,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "status",
        "types": [
          "*"
        ]
      },
      {
        "name": "error",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "error400",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#error400",
    "access": "public",
    "description": "Specific error handling functions",
    "lineNumber": 352,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "details",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "error403",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#error403",
    "access": "public",
    "description": null,
    "lineNumber": 357,
    "undocument": true,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "details",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "error404",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#error404",
    "access": "public",
    "description": null,
    "lineNumber": 361,
    "undocument": true,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "details",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "error500",
    "memberof": "lib/host/HostHttpServer.js~HostHttpServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/host/HostHttpServer.js~HostHttpServer#error500",
    "access": "public",
    "description": null,
    "lineNumber": 365,
    "undocument": true,
    "params": [
      {
        "name": "request",
        "types": [
          "*"
        ]
      },
      {
        "name": "response",
        "types": [
          "*"
        ]
      },
      {
        "name": "error",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "file",
    "name": "lib/index.js",
    "content": "// Various shortcut functions and variables providing a similar interface\n// to the package as for other Stencila language packages\n// e.g. https://github.com/stencila/r/blob/master/R/main.R\n\nconst pkg = require('../package')\nconst Host = require('./host/Host')\nconst host = new Host()\n\nconst version = pkg.version\n\nmodule.exports = {\n  version: version,\n  host: host,\n\n  register: host.register.bind(host),\n\n  start: host.start.bind(host),\n  stop: host.stop.bind(host),\n  run: host.run.bind(host),\n  spawn: host.spawn.bind(host),\n\n  compile: host.compile.bind(host)\n}\n",
    "static": true,
    "longname": "/home/travis/build/stencila/node/lib/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 219,
    "kind": "variable",
    "name": "host",
    "memberof": "lib/index.js",
    "static": true,
    "longname": "lib/index.js~host",
    "access": "public",
    "export": false,
    "importPath": "stencila-node",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "lib/host/Host.js~Host"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 220,
    "kind": "variable",
    "name": "version",
    "memberof": "lib/index.js",
    "static": true,
    "longname": "lib/index.js~version",
    "access": "public",
    "export": false,
    "importPath": "stencila-node",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "kind": "index",
    "content": "## Stencila for Node.js\n\n[![NPM](http://img.shields.io/npm/v/stencila-node.svg?style=flat)](https://www.npmjs.com/package/stencila-node)\n[![Build status](https://travis-ci.org/stencila/node.svg?branch=master)](https://travis-ci.org/stencila/node)\n[![Build status](https://ci.appveyor.com/api/projects/status/ipj7s8hm82809lj9/branch/master?svg=true)](https://ci.appveyor.com/project/nokome/node/)\n[![Code coverage](https://codecov.io/gh/stencila/node/branch/master/graph/badge.svg)](https://codecov.io/gh/stencila/node)\n[![Dependency status](https://david-dm.org/stencila/node.svg)](https://david-dm.org/stencila/node)\n[![Chat](https://badges.gitter.im/stencila/stencila.svg)](https://gitter.im/stencila/stencila)\n\n### Install\n\n```bash\nnpm install stencila-node --global --python=python2.7\n```\n\nThis package relies on dependencies with native add-ons (e.g. `better-sqlite3`, `xeromq`). So you will need to have `node-gyp` installed (https://github.com/nodejs/node-gyp#readme). The `--python` flag is necessary because, on OSX and Windows, `node-gyp` is only compatible with Python 2.7.\n\nRegister this Stencila package,\n\n```\nstencila-node register\n```\n\nThis creates a host manifest file in the Stencila hosts directory (e.g. `~/.stencila/hosts/node.js` on Linux). This file is used by Stencila Desktop and other packages to determine which Stencila hosts you have installed on your machine.\n\n### Use\n\nThis package lets you run JavaScript and other code from inside Stencila documents. First, you need to start serving the Stencila Host within this package. You can do that at a terminal,\n\n```bash\nstencila-node\n```\n\nor inside Node.js:\n\n```js\nconst stencila = require('stencila-node')\nstencila.run()\n```\n\nThis will serve a Stencila `Host` on localhost. You can then open your Stencila document from within the [Stencila Desktop](https://github.com/stencila/desktop). The host will be automatically detected by the desktop app and you'll be able to execute Javascript code cells from within your documents.\n\nYou can also use this package to compile libraries of Javascript functions for use within Stencila:\n\n```bash\nstencila-node compile \"~/stencila/source/libcore/\"\n```\n\nThis creates a minified Javascript bundle, in this example at `\"~/stencila/source/libcore/libcore.min.js`\n\nAPI documentation is available at https://stencila.github.io/node.\n\n### Discuss\n\nWe love feedback. Create a [new issue](https://github.com/stencila/node/issues/new), add to [existing issues](https://github.com/stencila/node/issues) or [chat](https://gitter.im/stencila/stencila) with members of the community.\n\n### Contribute\n\nSee [CONTRIBUTING.md](CONTRIBUTING.md).\n",
    "longname": "/home/travis/build/stencila/node/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"stencila-node\",\n  \"version\": \"0.28.15\",\n  \"description\": \"Stencila for Node.js\",\n  \"main\": \"lib/index.js\",\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"bin\": {\n    \"stencila-node\": \"bin/stencila-node.js\"\n  },\n  \"scripts\": {\n    \"lint\": \"standard \\\"lib/**/*.js\\\" \\\"bin/**/*.js\\\" \\\"test/**/*.js\\\"\",\n    \"check\": \"dependency-check ./package.json && dependency-check ./package.json --unused --no-dev --ignore-module request\",\n    \"test\": \"tape test | tap-spec\",\n    \"cover\": \"nyc --reporter=lcov --reporter=text npm test\",\n    \"docs\": \"esdoc\",\n    \"start\": \"nodemon bin/stencila-nodemon.js\",\n    \"prepublishOnly\": \"npm run lint && npm run test && npm run check && npm run docs\",\n    \"clean\": \"rimraf .nyc_output docs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/stencila/node.git\"\n  },\n  \"keywords\": [\n    \"data\",\n    \"documents\",\n    \"sheets\",\n    \"contexts\",\n    \"sessions\",\n    \"reproducibility\",\n    \"science\"\n  ],\n  \"author\": \"\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/stencila/node/issues\"\n  },\n  \"homepage\": \"https://github.com/stencila/node#readme\",\n  \"devDependencies\": {\n    \"dependency-check\": \"^3.1.0\",\n    \"esdoc\": \"^1.0.4\",\n    \"esdoc-node\": \"^1.0.3\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"node-mocks-http\": \"^1.6.7\",\n    \"nodemon\": \"^1.17.2\",\n    \"nyc\": \"^11.6.0\",\n    \"rimraf\": \"^2.6.2\",\n    \"standard\": \"^11.0.1\",\n    \"tap-spec\": \"^4.1.1\",\n    \"tape\": \"^4.9.0\"\n  },\n  \"dependencies\": {\n    \"acorn\": \"^5.5.3\",\n    \"address\": \"^1.0.3\",\n    \"astring\": \"^1.2.0\",\n    \"better-sqlite3\": \"^4.1.0\",\n    \"body\": \"^5.1.0\",\n    \"doctrine\": \"^2.1.0\",\n    \"execa\": \"^0.10.0\",\n    \"glob\": \"^7.1.2\",\n    \"http-shutdown\": \"^1.2.0\",\n    \"jmp\": \"^1.0.0\",\n    \"jsonwebtoken\": \"^8.2.0\",\n    \"kernelspecs\": \"^2.0.0\",\n    \"mkdirp\": \"^0.5.1\",\n    \"path-is-inside\": \"^1.0.2\",\n    \"request\": \"^2.85.0\",\n    \"request-promise\": \"^4.2.2\",\n    \"rollup\": \"^0.57.1\",\n    \"rollup-plugin-uglify\": \"^3.0.0\",\n    \"send\": \"^0.15.4\",\n    \"spawnteract\": \"^4.0.0\",\n    \"sqlite-parser\": \"^1.0.1\",\n    \"tmp\": \"0.0.33\",\n    \"untildify\": \"^3.0.2\",\n    \"uuid\": \"^3.2.1\"\n  },\n  \"esdoc\": {\n    \"source\": \"./lib\",\n    \"destination\": \"./docs\",\n    \"plugins\": [\n      {\n        \"name\": \"esdoc-standard-plugin\"\n      },\n      {\n        \"name\": \"esdoc-node\"\n      }\n    ]\n  },\n  \"standard\": {\n    \"ignore\": [\n      \"test/**/fixtures/**/*.js\"\n    ]\n  }\n}\n",
    "longname": "/home/travis/build/stencila/node/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]